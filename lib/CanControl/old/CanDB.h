/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Mon Apr 17 13:42:04 2023.
 */

#ifndef CAN_H
#define CAN_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CAN_ACTUATORS_STATUS_FRAME_ID (0xc1u)
#define CAN_ACTUATORS_SET_FRAME_ID (0xc2u)
#define CAN_ACTUATORS_RESET_FRAME_ID (0xc3u)
#define CAN_BATTERY_STATUS_FRAME_ID (0x221u)
#define CAN_BATTERY_ESTIMATES_FRAME_ID (0x222u)
#define CAN_BATTERY_OVERVOLTAGE_WARNING_FRAME_ID (0x223u)
#define CAN_BATTERY_UNDERVOLTAGE_WARNING_FRAME_ID (0x224u)
#define CAN_BUZZER_BEEP_FRAME_ID (0x701u)
#define CAN_BUZZER_PLAY_NOTE_FRAME_ID (0x702u)
#define CAN_BUZZER_START_FRAME_ID (0x703u)
#define CAN_BUZZER_STOP_FRAME_ID (0x704u)
#define CAN_CONTROL_MODE_FRAME_ID (0x201u)
#define CAN_GPS_STATUS_FRAME_ID (0x421u)
#define CAN_GPS_LATITUDE_FRAME_ID (0x422u)
#define CAN_GPS_LONGITUDE_FRAME_ID (0x423u)
#define CAN_GPS_DATE_FRAME_ID (0x424u)
#define CAN_IMU_STATUS_FRAME_ID (0x401u)
#define CAN_IMU_ORIENTATION_FRAME_ID (0x402u)
#define CAN_IMU_LINEAR_ACCELERATION_FRAME_ID (0x403u)
#define CAN_IMU_MAGNETIC_FIELD_FRAME_ID (0x404u)
#define CAN_IMU_GYRATION_FRAME_ID (0x405u)
#define CAN_METAL_DETECTOR_STATUS_FRAME_ID (0x441u)
#define CAN_METAL_DETECTOR_VALUE_1234_FRAME_ID (0x442u)
#define CAN_METAL_DETECTOR_VALUE_5678_FRAME_ID (0x443u)
#define CAN_METAL_DETECTOR_ESTIMATED_POSITION_FRAME_ID (0x444u)
#define CAN_ODRIVE_LEFT_HEARTBEAT_FRAME_ID (0x21u)
#define CAN_ODRIVE_LEFT_ESTOP_FRAME_ID (0x22u)
#define CAN_ODRIVE_LEFT_GET_MOTOR_ERROR_FRAME_ID (0x23u)
#define CAN_ODRIVE_LEFT_GET_ENCODER_ERROR_FRAME_ID (0x24u)
#define CAN_ODRIVE_LEFT_SET_AXIS_STATE_FRAME_ID (0x27u)
#define CAN_ODRIVE_LEFT_GET_ENCODER_ESTIMATES_FRAME_ID (0x29u)
#define CAN_ODRIVE_LEFT_GET_ENCODER_COUNT_FRAME_ID (0x2au)
#define CAN_ODRIVE_LEFT_SET_CONTROLLER_MODE_FRAME_ID (0x2bu)
#define CAN_ODRIVE_LEFT_SET_INPUT_POS_FRAME_ID (0x2cu)
#define CAN_ODRIVE_LEFT_SET_INPUT_VEL_FRAME_ID (0x2du)
#define CAN_ODRIVE_LEFT_SET_INPUT_TORQUE_FRAME_ID (0x2eu)
#define CAN_ODRIVE_LEFT_SET_LIMITS_FRAME_ID (0x2fu)
#define CAN_ODRIVE_LEFT_GET_VBUS_VOLTAGE_FRAME_ID (0x37u)
#define CAN_ODRIVE_LEFT_CLEAR_ERRORS_FRAME_ID (0x38u)
#define CAN_ODRIVE_RIGHT_HEARTBEAT_FRAME_ID (0x61u)
#define CAN_ODRIVE_RIGHT_ESTOP_FRAME_ID (0x62u)
#define CAN_ODRIVE_RIGHT_GET_MOTOR_ERROR_FRAME_ID (0x63u)
#define CAN_ODRIVE_RIGHT_GET_ENCODER_ERROR_FRAME_ID (0x64u)
#define CAN_ODRIVE_RIGHT_SET_AXIS_STATE_FRAME_ID (0x67u)
#define CAN_ODRIVE_RIGHT_GET_ENCODER_ESTIMATES_FRAME_ID (0x69u)
#define CAN_ODRIVE_RIGHT_GET_ENCODER_COUNT_FRAME_ID (0x6au)
#define CAN_ODRIVE_RIGHT_SET_CONTROLLER_MODE_FRAME_ID (0x6bu)
#define CAN_ODRIVE_RIGHT_SET_INPUT_POS_FRAME_ID (0x6cu)
#define CAN_ODRIVE_RIGHT_SET_INPUT_VEL_FRAME_ID (0x6du)
#define CAN_ODRIVE_RIGHT_SET_INPUT_TORQUE_FRAME_ID (0x6eu)
#define CAN_ODRIVE_RIGHT_SET_LIMITS_FRAME_ID (0x6fu)
#define CAN_ODRIVE_RIGHT_GET_VBUS_VOLTAGE_FRAME_ID (0x77u)
#define CAN_ODRIVE_RIGHT_CLEAR_ERRORS_FRAME_ID (0x78u)
#define CAN_TEMPERATURE_IMU_STATUS_FRAME_ID (0x241u)
#define CAN_TEMPERATURE_IMU_TEMPERATURE_FRAME_ID (0x242u)
#define CAN_TEMPERATURE_IMU_WARNINGS_FRAME_ID (0x243u)
#define CAN_TEMPERATURE_EXTERNAL_STATUS_FRAME_ID (0x261u)
#define CAN_TEMPERATURE_EXTERNAL_TEMPERATURE_FRAME_ID (0x262u)
#define CAN_TEMPERATURE_EXTERNAL_WARNINGS_FRAME_ID (0x263u)
#define CAN_TEMPERATURE_SENSOR_BOARD_STATUS_FRAME_ID (0x281u)
#define CAN_TEMPERATURE_SENSOR_BOARD_TEMPERATURE_FRAME_ID (0x282u)
#define CAN_TEMPERATURE_SENSOR_BOARD_WARNINGS_FRAME_ID (0x283u)
#define CAN_TEMPERATURE_POWER_BOARD_STATUS_FRAME_ID (0x2a1u)
#define CAN_TEMPERATURE_POWER_BOARD_TEMPERATURE_FRAME_ID (0x2a2u)
#define CAN_TEMPERATURE_POWER_BOARD_WARNINGS_FRAME_ID (0x2a3u)
#define CAN_TEMPERATURE_METAL_DETECTOR_BOARD_STATUS_FRAME_ID (0x2c1u)
#define CAN_TEMPERATURE_METAL_DETECTOR_BOARD_TEMPERATURE_FRAME_ID (0x2c2u)
#define CAN_TEMPERATURE_METAL_DETECTOR_BOARD_WARNINGS_FRAME_ID (0x2c3u)
#define CAN_KONARM_1_STATUS_FRAME_ID (0x611u)
#define CAN_KONARM_1_SET_POS_FRAME_ID (0x612u)
#define CAN_KONARM_1_GET_POS_FRAME_ID (0x613u)
#define CAN_KONARM_1_CLEAR_ERRORS_FRAME_ID (0x614u)
#define CAN_KONARM_2_STATUS_FRAME_ID (0x621u)
#define CAN_KONARM_2_SET_POS_FRAME_ID (0x622u)
#define CAN_KONARM_2_GET_POS_FRAME_ID (0x623u)
#define CAN_KONARM_2_CLEAR_ERRORS_FRAME_ID (0x624u)
#define CAN_KONARM_3_STATUS_FRAME_ID (0x631u)
#define CAN_KONARM_3_SET_POS_FRAME_ID (0x632u)
#define CAN_KONARM_3_GET_POS_FRAME_ID (0x633u)
#define CAN_KONARM_3_CLEAR_ERRORS_FRAME_ID (0x634u)
#define CAN_KONARM_4_STATUS_FRAME_ID (0x641u)
#define CAN_KONARM_4_SET_POS_FRAME_ID (0x642u)
#define CAN_KONARM_4_GET_POS_FRAME_ID (0x643u)
#define CAN_KONARM_4_CLEAR_ERRORS_FRAME_ID (0x644u)
#define CAN_KONARM_5_STATUS_FRAME_ID (0x651u)
#define CAN_KONARM_5_SET_POS_FRAME_ID (0x652u)
#define CAN_KONARM_5_GET_POS_FRAME_ID (0x653u)
#define CAN_KONARM_5_CLEAR_ERRORS_FRAME_ID (0x654u)

/* Frame lengths in bytes. */
#define CAN_ACTUATORS_STATUS_LENGTH (1u)
#define CAN_ACTUATORS_SET_LENGTH (1u)
#define CAN_ACTUATORS_RESET_LENGTH (1u)
#define CAN_BATTERY_STATUS_LENGTH (1u)
#define CAN_BATTERY_ESTIMATES_LENGTH (3u)
#define CAN_BATTERY_OVERVOLTAGE_WARNING_LENGTH (2u)
#define CAN_BATTERY_UNDERVOLTAGE_WARNING_LENGTH (2u)
#define CAN_BUZZER_BEEP_LENGTH (0u)
#define CAN_BUZZER_PLAY_NOTE_LENGTH (4u)
#define CAN_BUZZER_START_LENGTH (2u)
#define CAN_BUZZER_STOP_LENGTH (0u)
#define CAN_CONTROL_MODE_LENGTH (1u)
#define CAN_GPS_STATUS_LENGTH (2u)
#define CAN_GPS_LATITUDE_LENGTH (8u)
#define CAN_GPS_LONGITUDE_LENGTH (8u)
#define CAN_GPS_DATE_LENGTH (6u)
#define CAN_IMU_STATUS_LENGTH (1u)
#define CAN_IMU_ORIENTATION_LENGTH (8u)
#define CAN_IMU_LINEAR_ACCELERATION_LENGTH (6u)
#define CAN_IMU_MAGNETIC_FIELD_LENGTH (6u)
#define CAN_IMU_GYRATION_LENGTH (6u)
#define CAN_METAL_DETECTOR_STATUS_LENGTH (2u)
#define CAN_METAL_DETECTOR_VALUE_1234_LENGTH (8u)
#define CAN_METAL_DETECTOR_VALUE_5678_LENGTH (8u)
#define CAN_METAL_DETECTOR_ESTIMATED_POSITION_LENGTH (6u)
#define CAN_ODRIVE_LEFT_HEARTBEAT_LENGTH (6u)
#define CAN_ODRIVE_LEFT_ESTOP_LENGTH (0u)
#define CAN_ODRIVE_LEFT_GET_MOTOR_ERROR_LENGTH (4u)
#define CAN_ODRIVE_LEFT_GET_ENCODER_ERROR_LENGTH (4u)
#define CAN_ODRIVE_LEFT_SET_AXIS_STATE_LENGTH (4u)
#define CAN_ODRIVE_LEFT_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define CAN_ODRIVE_LEFT_GET_ENCODER_COUNT_LENGTH (8u)
#define CAN_ODRIVE_LEFT_SET_CONTROLLER_MODE_LENGTH (8u)
#define CAN_ODRIVE_LEFT_SET_INPUT_POS_LENGTH (8u)
#define CAN_ODRIVE_LEFT_SET_INPUT_VEL_LENGTH (8u)
#define CAN_ODRIVE_LEFT_SET_INPUT_TORQUE_LENGTH (4u)
#define CAN_ODRIVE_LEFT_SET_LIMITS_LENGTH (8u)
#define CAN_ODRIVE_LEFT_GET_VBUS_VOLTAGE_LENGTH (4u)
#define CAN_ODRIVE_LEFT_CLEAR_ERRORS_LENGTH (0u)
#define CAN_ODRIVE_RIGHT_HEARTBEAT_LENGTH (6u)
#define CAN_ODRIVE_RIGHT_ESTOP_LENGTH (0u)
#define CAN_ODRIVE_RIGHT_GET_MOTOR_ERROR_LENGTH (4u)
#define CAN_ODRIVE_RIGHT_GET_ENCODER_ERROR_LENGTH (4u)
#define CAN_ODRIVE_RIGHT_SET_AXIS_STATE_LENGTH (4u)
#define CAN_ODRIVE_RIGHT_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define CAN_ODRIVE_RIGHT_GET_ENCODER_COUNT_LENGTH (8u)
#define CAN_ODRIVE_RIGHT_SET_CONTROLLER_MODE_LENGTH (8u)
#define CAN_ODRIVE_RIGHT_SET_INPUT_POS_LENGTH (8u)
#define CAN_ODRIVE_RIGHT_SET_INPUT_VEL_LENGTH (8u)
#define CAN_ODRIVE_RIGHT_SET_INPUT_TORQUE_LENGTH (4u)
#define CAN_ODRIVE_RIGHT_SET_LIMITS_LENGTH (8u)
#define CAN_ODRIVE_RIGHT_GET_VBUS_VOLTAGE_LENGTH (4u)
#define CAN_ODRIVE_RIGHT_CLEAR_ERRORS_LENGTH (0u)
#define CAN_TEMPERATURE_IMU_STATUS_LENGTH (1u)
#define CAN_TEMPERATURE_IMU_TEMPERATURE_LENGTH (1u)
#define CAN_TEMPERATURE_IMU_WARNINGS_LENGTH (1u)
#define CAN_TEMPERATURE_EXTERNAL_STATUS_LENGTH (1u)
#define CAN_TEMPERATURE_EXTERNAL_TEMPERATURE_LENGTH (4u)
#define CAN_TEMPERATURE_EXTERNAL_WARNINGS_LENGTH (2u)
#define CAN_TEMPERATURE_SENSOR_BOARD_STATUS_LENGTH (1u)
#define CAN_TEMPERATURE_SENSOR_BOARD_TEMPERATURE_LENGTH (3u)
#define CAN_TEMPERATURE_SENSOR_BOARD_WARNINGS_LENGTH (2u)
#define CAN_TEMPERATURE_POWER_BOARD_STATUS_LENGTH (1u)
#define CAN_TEMPERATURE_POWER_BOARD_TEMPERATURE_LENGTH (3u)
#define CAN_TEMPERATURE_POWER_BOARD_WARNINGS_LENGTH (2u)
#define CAN_TEMPERATURE_METAL_DETECTOR_BOARD_STATUS_LENGTH (1u)
#define CAN_TEMPERATURE_METAL_DETECTOR_BOARD_TEMPERATURE_LENGTH (1u)
#define CAN_TEMPERATURE_METAL_DETECTOR_BOARD_WARNINGS_LENGTH (1u)
#define CAN_KONARM_1_STATUS_LENGTH (1u)
#define CAN_KONARM_1_SET_POS_LENGTH (8u)
#define CAN_KONARM_1_GET_POS_LENGTH (8u)
#define CAN_KONARM_1_CLEAR_ERRORS_LENGTH (0u)
#define CAN_KONARM_2_STATUS_LENGTH (1u)
#define CAN_KONARM_2_SET_POS_LENGTH (8u)
#define CAN_KONARM_2_GET_POS_LENGTH (8u)
#define CAN_KONARM_2_CLEAR_ERRORS_LENGTH (0u)
#define CAN_KONARM_3_STATUS_LENGTH (1u)
#define CAN_KONARM_3_SET_POS_LENGTH (8u)
#define CAN_KONARM_3_GET_POS_LENGTH (8u)
#define CAN_KONARM_3_CLEAR_ERRORS_LENGTH (0u)
#define CAN_KONARM_4_STATUS_LENGTH (1u)
#define CAN_KONARM_4_SET_POS_LENGTH (8u)
#define CAN_KONARM_4_GET_POS_LENGTH (8u)
#define CAN_KONARM_4_CLEAR_ERRORS_LENGTH (0u)
#define CAN_KONARM_5_STATUS_LENGTH (1u)
#define CAN_KONARM_5_SET_POS_LENGTH (8u)
#define CAN_KONARM_5_GET_POS_LENGTH (8u)
#define CAN_KONARM_5_CLEAR_ERRORS_LENGTH (0u)


/* Extended or standard frame types. */
#define CAN_ACTUATORS_STATUS_IS_EXTENDED (0)
#define CAN_ACTUATORS_SET_IS_EXTENDED (0)
#define CAN_ACTUATORS_RESET_IS_EXTENDED (0)
#define CAN_BATTERY_STATUS_IS_EXTENDED (0)
#define CAN_BATTERY_ESTIMATES_IS_EXTENDED (0)
#define CAN_BATTERY_OVERVOLTAGE_WARNING_IS_EXTENDED (0)
#define CAN_BATTERY_UNDERVOLTAGE_WARNING_IS_EXTENDED (0)
#define CAN_BUZZER_BEEP_IS_EXTENDED (0)
#define CAN_BUZZER_PLAY_NOTE_IS_EXTENDED (0)
#define CAN_BUZZER_START_IS_EXTENDED (0)
#define CAN_BUZZER_STOP_IS_EXTENDED (0)
#define CAN_CONTROL_MODE_IS_EXTENDED (0)
#define CAN_GPS_STATUS_IS_EXTENDED (0)
#define CAN_GPS_LATITUDE_IS_EXTENDED (0)
#define CAN_GPS_LONGITUDE_IS_EXTENDED (0)
#define CAN_GPS_DATE_IS_EXTENDED (0)
#define CAN_IMU_STATUS_IS_EXTENDED (0)
#define CAN_IMU_ORIENTATION_IS_EXTENDED (0)
#define CAN_IMU_LINEAR_ACCELERATION_IS_EXTENDED (0)
#define CAN_IMU_MAGNETIC_FIELD_IS_EXTENDED (0)
#define CAN_IMU_GYRATION_IS_EXTENDED (0)
#define CAN_METAL_DETECTOR_STATUS_IS_EXTENDED (0)
#define CAN_METAL_DETECTOR_VALUE_1234_IS_EXTENDED (0)
#define CAN_METAL_DETECTOR_VALUE_5678_IS_EXTENDED (0)
#define CAN_METAL_DETECTOR_ESTIMATED_POSITION_IS_EXTENDED (0)
#define CAN_ODRIVE_LEFT_HEARTBEAT_IS_EXTENDED (0)
#define CAN_ODRIVE_LEFT_ESTOP_IS_EXTENDED (0)
#define CAN_ODRIVE_LEFT_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define CAN_ODRIVE_LEFT_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define CAN_ODRIVE_LEFT_SET_AXIS_STATE_IS_EXTENDED (0)
#define CAN_ODRIVE_LEFT_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define CAN_ODRIVE_LEFT_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define CAN_ODRIVE_LEFT_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define CAN_ODRIVE_LEFT_SET_INPUT_POS_IS_EXTENDED (0)
#define CAN_ODRIVE_LEFT_SET_INPUT_VEL_IS_EXTENDED (0)
#define CAN_ODRIVE_LEFT_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define CAN_ODRIVE_LEFT_SET_LIMITS_IS_EXTENDED (0)
#define CAN_ODRIVE_LEFT_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define CAN_ODRIVE_LEFT_CLEAR_ERRORS_IS_EXTENDED (0)
#define CAN_ODRIVE_RIGHT_HEARTBEAT_IS_EXTENDED (0)
#define CAN_ODRIVE_RIGHT_ESTOP_IS_EXTENDED (0)
#define CAN_ODRIVE_RIGHT_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define CAN_ODRIVE_RIGHT_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define CAN_ODRIVE_RIGHT_SET_AXIS_STATE_IS_EXTENDED (0)
#define CAN_ODRIVE_RIGHT_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define CAN_ODRIVE_RIGHT_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define CAN_ODRIVE_RIGHT_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define CAN_ODRIVE_RIGHT_SET_INPUT_POS_IS_EXTENDED (0)
#define CAN_ODRIVE_RIGHT_SET_INPUT_VEL_IS_EXTENDED (0)
#define CAN_ODRIVE_RIGHT_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define CAN_ODRIVE_RIGHT_SET_LIMITS_IS_EXTENDED (0)
#define CAN_ODRIVE_RIGHT_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define CAN_ODRIVE_RIGHT_CLEAR_ERRORS_IS_EXTENDED (0)
#define CAN_TEMPERATURE_IMU_STATUS_IS_EXTENDED (0)
#define CAN_TEMPERATURE_IMU_TEMPERATURE_IS_EXTENDED (0)
#define CAN_TEMPERATURE_IMU_WARNINGS_IS_EXTENDED (0)
#define CAN_TEMPERATURE_EXTERNAL_STATUS_IS_EXTENDED (0)
#define CAN_TEMPERATURE_EXTERNAL_TEMPERATURE_IS_EXTENDED (0)
#define CAN_TEMPERATURE_EXTERNAL_WARNINGS_IS_EXTENDED (0)
#define CAN_TEMPERATURE_SENSOR_BOARD_STATUS_IS_EXTENDED (0)
#define CAN_TEMPERATURE_SENSOR_BOARD_TEMPERATURE_IS_EXTENDED (0)
#define CAN_TEMPERATURE_SENSOR_BOARD_WARNINGS_IS_EXTENDED (0)
#define CAN_TEMPERATURE_POWER_BOARD_STATUS_IS_EXTENDED (0)
#define CAN_TEMPERATURE_POWER_BOARD_TEMPERATURE_IS_EXTENDED (0)
#define CAN_TEMPERATURE_POWER_BOARD_WARNINGS_IS_EXTENDED (0)
#define CAN_TEMPERATURE_METAL_DETECTOR_BOARD_STATUS_IS_EXTENDED (0)
#define CAN_TEMPERATURE_METAL_DETECTOR_BOARD_TEMPERATURE_IS_EXTENDED (0)
#define CAN_TEMPERATURE_METAL_DETECTOR_BOARD_WARNINGS_IS_EXTENDED (0)
#define CAN_KONARM_1_STATUS_IS_EXTENDED (0)
#define CAN_KONARM_1_SET_POS_IS_EXTENDED (0)
#define CAN_KONARM_1_GET_POS_IS_EXTENDED (0)
#define CAN_KONARM_1_CLEAR_ERRORS_IS_EXTENDED (0)
#define CAN_KONARM_2_STATUS_IS_EXTENDED (0)
#define CAN_KONARM_2_SET_POS_IS_EXTENDED (0)
#define CAN_KONARM_2_GET_POS_IS_EXTENDED (0)
#define CAN_KONARM_2_CLEAR_ERRORS_IS_EXTENDED (0)
#define CAN_KONARM_3_STATUS_IS_EXTENDED (0)
#define CAN_KONARM_3_SET_POS_IS_EXTENDED (0)
#define CAN_KONARM_3_GET_POS_IS_EXTENDED (0)
#define CAN_KONARM_3_CLEAR_ERRORS_IS_EXTENDED (0)
#define CAN_KONARM_4_STATUS_IS_EXTENDED (0)
#define CAN_KONARM_4_SET_POS_IS_EXTENDED (0)
#define CAN_KONARM_4_GET_POS_IS_EXTENDED (0)
#define CAN_KONARM_4_CLEAR_ERRORS_IS_EXTENDED (0)
#define CAN_KONARM_5_STATUS_IS_EXTENDED (0)
#define CAN_KONARM_5_SET_POS_IS_EXTENDED (0)
#define CAN_KONARM_5_GET_POS_IS_EXTENDED (0)
#define CAN_KONARM_5_CLEAR_ERRORS_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define CAN_BATTERY_STATUS_STATUS_UNKNOWN_CHOICE (0u)
#define CAN_BATTERY_STATUS_STATUS_CHARGING_CHOICE (1u)
#define CAN_BATTERY_STATUS_STATUS_DISCHARGING_CHOICE (2u)
#define CAN_BATTERY_STATUS_STATUS_NOT_CHARGING_CHOICE (3u)
#define CAN_BATTERY_STATUS_STATUS_FULL_CHOICE (4u)

#define CAN_CONTROL_MODE_MODE_UNKNOWN_CHOICE (0u)
#define CAN_CONTROL_MODE_MODE_MANUAL_CHOICE (1u)
#define CAN_CONTROL_MODE_MODE_AUTO_CHOICE (2u)

#define CAN_GPS_STATUS_STATUS_OK_CHOICE (1u)
#define CAN_GPS_STATUS_STATUS_DISCONNECTED_CHOICE (2u)
#define CAN_GPS_STATUS_STATUS_ERROR_CHOICE (3u)

#define CAN_GPS_STATUS_SIGNAL_UNABLE_TO_FIX_POSITION_CHOICE (-1)
#define CAN_GPS_STATUS_SIGNAL_UNAUGMENTED_FIX_CHOICE (0)
#define CAN_GPS_STATUS_SIGNAL_SATELLITE_BASED_AUGMENTATION_CHOICE (1)
#define CAN_GPS_STATUS_SIGNAL_GROUND_BASED_AUGMENTATION_CHOICE (2)

#define CAN_IMU_STATUS_STATUS_OK_CHOICE (1u)
#define CAN_IMU_STATUS_STATUS_DISCONNECTED_CHOICE (2u)
#define CAN_IMU_STATUS_STATUS_ERROR_CHOICE (3u)

#define CAN_METAL_DETECTOR_STATUS_CHANNEL_1_OK_CHOICE (1u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_1_DISCONNECTED_CHOICE (2u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_1_ERROR_CHOICE (3u)

#define CAN_METAL_DETECTOR_STATUS_CHANNEL_2_OK_CHOICE (1u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_2_DISCONNECTED_CHOICE (2u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_2_ERROR_CHOICE (3u)

#define CAN_METAL_DETECTOR_STATUS_CHANNEL_3_OK_CHOICE (1u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_3_DISCONNECTED_CHOICE (2u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_3_ERROR_CHOICE (3u)

#define CAN_METAL_DETECTOR_STATUS_CHANNEL_4_OK_CHOICE (1u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_4_DISCONNECTED_CHOICE (2u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_4_ERROR_CHOICE (3u)

#define CAN_METAL_DETECTOR_STATUS_CHANNEL_5_OK_CHOICE (1u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_5_DISCONNECTED_CHOICE (2u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_5_ERROR_CHOICE (3u)

#define CAN_METAL_DETECTOR_STATUS_CHANNEL_6_OK_CHOICE (1u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_6_DISCONNECTED_CHOICE (2u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_6_ERROR_CHOICE (3u)

#define CAN_METAL_DETECTOR_STATUS_CHANNEL_7_OK_CHOICE (1u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_7_DISCONNECTED_CHOICE (2u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_7_ERROR_CHOICE (3u)

#define CAN_METAL_DETECTOR_STATUS_CHANNEL_8_OK_CHOICE (1u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_8_DISCONNECTED_CHOICE (2u)
#define CAN_METAL_DETECTOR_STATUS_CHANNEL_8_ERROR_CHOICE (3u)

#define CAN_TEMPERATURE_IMU_STATUS_ACCELEROMETER_OK_CHOICE (1u)
#define CAN_TEMPERATURE_IMU_STATUS_ACCELEROMETER_DISCONNECTED_CHOICE (2u)
#define CAN_TEMPERATURE_IMU_STATUS_ACCELEROMETER_ERROR_CHOICE (3u)

#define CAN_TEMPERATURE_EXTERNAL_STATUS_EXTERNAL_1_OK_CHOICE (1u)
#define CAN_TEMPERATURE_EXTERNAL_STATUS_EXTERNAL_1_DISCONNECTED_CHOICE (2u)
#define CAN_TEMPERATURE_EXTERNAL_STATUS_EXTERNAL_1_ERROR_CHOICE (3u)

#define CAN_TEMPERATURE_EXTERNAL_STATUS_EXTERNAL_2_OK_CHOICE (1u)
#define CAN_TEMPERATURE_EXTERNAL_STATUS_EXTERNAL_2_DISCONNECTED_CHOICE (2u)
#define CAN_TEMPERATURE_EXTERNAL_STATUS_EXTERNAL_2_ERROR_CHOICE (3u)

#define CAN_TEMPERATURE_EXTERNAL_STATUS_EXTERNAL_3_OK_CHOICE (1u)
#define CAN_TEMPERATURE_EXTERNAL_STATUS_EXTERNAL_3_DISCONNECTED_CHOICE (2u)
#define CAN_TEMPERATURE_EXTERNAL_STATUS_EXTERNAL_3_ERROR_CHOICE (3u)

#define CAN_TEMPERATURE_EXTERNAL_STATUS_EXTERNAL_4_OK_CHOICE (1u)
#define CAN_TEMPERATURE_EXTERNAL_STATUS_EXTERNAL_4_DISCONNECTED_CHOICE (2u)
#define CAN_TEMPERATURE_EXTERNAL_STATUS_EXTERNAL_4_ERROR_CHOICE (3u)

#define CAN_TEMPERATURE_SENSOR_BOARD_STATUS_UCONTROLLER_OK_CHOICE (1u)
#define CAN_TEMPERATURE_SENSOR_BOARD_STATUS_UCONTROLLER_DISCONNECTED_CHOICE (2u)
#define CAN_TEMPERATURE_SENSOR_BOARD_STATUS_UCONTROLLER_ERROR_CHOICE (3u)

#define CAN_TEMPERATURE_SENSOR_BOARD_STATUS_AMBIENT_OK_CHOICE (1u)
#define CAN_TEMPERATURE_SENSOR_BOARD_STATUS_AMBIENT_DISCONNECTED_CHOICE (2u)
#define CAN_TEMPERATURE_SENSOR_BOARD_STATUS_AMBIENT_ERROR_CHOICE (3u)

#define CAN_TEMPERATURE_SENSOR_BOARD_STATUS_LDO_OK_CHOICE (1u)
#define CAN_TEMPERATURE_SENSOR_BOARD_STATUS_LDO_DISCONNECTED_CHOICE (2u)
#define CAN_TEMPERATURE_SENSOR_BOARD_STATUS_LDO_ERROR_CHOICE (3u)

#define CAN_TEMPERATURE_POWER_BOARD_STATUS_UCONTROLLER_OK_CHOICE (1u)
#define CAN_TEMPERATURE_POWER_BOARD_STATUS_UCONTROLLER_DISCONNECTED_CHOICE (2u)
#define CAN_TEMPERATURE_POWER_BOARD_STATUS_UCONTROLLER_ERROR_CHOICE (3u)

#define CAN_TEMPERATURE_POWER_BOARD_STATUS_AMBIENT_OK_CHOICE (1u)
#define CAN_TEMPERATURE_POWER_BOARD_STATUS_AMBIENT_DISCONNECTED_CHOICE (2u)
#define CAN_TEMPERATURE_POWER_BOARD_STATUS_AMBIENT_ERROR_CHOICE (3u)

#define CAN_TEMPERATURE_POWER_BOARD_STATUS_MOSFETS_OK_CHOICE (1u)
#define CAN_TEMPERATURE_POWER_BOARD_STATUS_MOSFETS_DISCONNECTED_CHOICE (2u)
#define CAN_TEMPERATURE_POWER_BOARD_STATUS_MOSFETS_ERROR_CHOICE (3u)

#define CAN_TEMPERATURE_METAL_DETECTOR_BOARD_STATUS_UCONTROLLER_OK_CHOICE (1u)
#define CAN_TEMPERATURE_METAL_DETECTOR_BOARD_STATUS_UCONTROLLER_DISCONNECTED_CHOICE (2u)
#define CAN_TEMPERATURE_METAL_DETECTOR_BOARD_STATUS_UCONTROLLER_ERROR_CHOICE (3u)

#define CAN_KONARM_1_STATUS_STATUS_OK_CHOICE (1u)
#define CAN_KONARM_1_STATUS_STATUS_FAULT_CHOICE (2u)
#define CAN_KONARM_1_STATUS_STATUS_OVERHEAT_CHOICE (3u)
#define CAN_KONARM_1_STATUS_STATUS_EMERGENCY_STOP_CHOICE (4u)

#define CAN_KONARM_2_STATUS_STATUS_OK_CHOICE (1u)
#define CAN_KONARM_2_STATUS_STATUS_FAULT_CHOICE (2u)
#define CAN_KONARM_2_STATUS_STATUS_OVERHEAT_CHOICE (3u)
#define CAN_KONARM_2_STATUS_STATUS_EMERGENCY_STOP_CHOICE (4u)

#define CAN_KONARM_3_STATUS_STATUS_OK_CHOICE (1u)
#define CAN_KONARM_3_STATUS_STATUS_FAULT_CHOICE (2u)
#define CAN_KONARM_3_STATUS_STATUS_OVERHEAT_CHOICE (3u)
#define CAN_KONARM_3_STATUS_STATUS_EMERGENCY_STOP_CHOICE (4u)

#define CAN_KONARM_4_STATUS_STATUS_OK_CHOICE (1u)
#define CAN_KONARM_4_STATUS_STATUS_FAULT_CHOICE (2u)
#define CAN_KONARM_4_STATUS_STATUS_OVERHEAT_CHOICE (3u)
#define CAN_KONARM_4_STATUS_STATUS_EMERGENCY_STOP_CHOICE (4u)

#define CAN_KONARM_5_STATUS_STATUS_OK_CHOICE (1u)
#define CAN_KONARM_5_STATUS_STATUS_FAULT_CHOICE (2u)
#define CAN_KONARM_5_STATUS_STATUS_OVERHEAT_CHOICE (3u)
#define CAN_KONARM_5_STATUS_STATUS_EMERGENCY_STOP_CHOICE (4u)

/**
 * Signals in message actuators_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_actuators_status_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t light1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t light2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t light3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t light4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t horn;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t magnet;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t servos;
};

/**
 * Signals in message actuators_set.
 *
 * All signal values are as on the CAN bus.
 */
struct can_actuators_set_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t light1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t light2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t light3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t light4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t horn;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t magnet;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t servos;
};

/**
 * Signals in message actuators_reset.
 *
 * All signal values are as on the CAN bus.
 */
struct can_actuators_reset_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t light1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t light2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t light3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t light4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t horn;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t magnet;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t servos;
};

/**
 * Signals in message battery_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_battery_status_t {
    /**
     * Range: 0..4 (0..4 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t status;
};

/**
 * Signals in message battery_estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct can_battery_estimates_t {
    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t voltage;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fill_level;
};

/**
 * Signals in message battery_overvoltage_warning.
 *
 * All signal values are as on the CAN bus.
 */
struct can_battery_overvoltage_warning_t {
    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t voltage;
};

/**
 * Signals in message battery_undervoltage_warning.
 *
 * All signal values are as on the CAN bus.
 */
struct can_battery_undervoltage_warning_t {
    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t voltage;
};

/**
 * Signals in message buzzer_beep.
 *
 * All signal values are as on the CAN bus.
 */
struct can_buzzer_beep_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message buzzer_play_note.
 *
 * All signal values are as on the CAN bus.
 */
struct can_buzzer_play_note_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t frequency;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t duration;
};

/**
 * Signals in message buzzer_start.
 *
 * All signal values are as on the CAN bus.
 */
struct can_buzzer_start_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t frequency;
};

/**
 * Signals in message buzzer_stop.
 *
 * All signal values are as on the CAN bus.
 */
struct can_buzzer_stop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message control_mode.
 *
 * All signal values are as on the CAN bus.
 */
struct can_control_mode_t {
    /**
     * Range: 0..2 (0..2 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;
};

/**
 * Signals in message gps_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_gps_status_t {
    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t status;

    /**
     * Range: -1..2 (-1..2 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t signal;
};

/**
 * Signals in message gps_latitude.
 *
 * All signal values are as on the CAN bus.
 */
struct can_gps_latitude_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double latitude;
};

/**
 * Signals in message gps_longitude.
 *
 * All signal values are as on the CAN bus.
 */
struct can_gps_longitude_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double longitude;
};

/**
 * Signals in message gps_date.
 *
 * All signal values are as on the CAN bus.
 */
struct can_gps_date_t {
    /**
     * Range: 0..99 (0..99 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t year;

    /**
     * Range: 1..12 (1..12 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t month;

    /**
     * Range: 1..31 (1..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t day;

    /**
     * Range: 0..23 (0..23 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hour;

    /**
     * Range: 0..59 (0..59 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t minute;

    /**
     * Range: 0..59 (0..59 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t second;
};

/**
 * Signals in message imu_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_imu_status_t {
    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t status;
};

/**
 * Signals in message imu_orientation.
 *
 * All signal values are as on the CAN bus.
 */
struct can_imu_orientation_t {
    /**
     * Range: -
     * Scale: 6.103515625e-05
     * Offset: 0
     */
    int16_t w;

    /**
     * Range: -
     * Scale: 6.103515625e-05
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: -
     * Scale: 6.103515625e-05
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: -
     * Scale: 6.103515625e-05
     * Offset: 0
     */
    int16_t z;
};

/**
 * Signals in message imu_linear_acceleration.
 *
 * All signal values are as on the CAN bus.
 */
struct can_imu_linear_acceleration_t {
    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t z;
};

/**
 * Signals in message imu_magnetic_field.
 *
 * All signal values are as on the CAN bus.
 */
struct can_imu_magnetic_field_t {
    /**
     * Range: -
     * Scale: 0.0625
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: -
     * Scale: 0.0625
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: -
     * Scale: 0.0625
     * Offset: 0
     */
    int16_t z;
};

/**
 * Signals in message imu_gyration.
 *
 * All signal values are as on the CAN bus.
 */
struct can_imu_gyration_t {
    /**
     * Range: -
     * Scale: 0.0011111111111111111
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: -
     * Scale: 0.0011111111111111111
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: -
     * Scale: 0.0011111111111111111
     * Offset: 0
     */
    int16_t z;
};

/**
 * Signals in message metal_detector_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_metal_detector_status_t {
    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t channel_1;

    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t channel_2;

    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t channel_3;

    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t channel_4;

    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t channel_5;

    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t channel_6;

    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t channel_7;

    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t channel_8;
};

/**
 * Signals in message metal_detector_value_1234.
 *
 * All signal values are as on the CAN bus.
 */
struct can_metal_detector_value_1234_t {
    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t channel_1;

    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t channel_2;

    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t channel_3;

    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t channel_4;
};

/**
 * Signals in message metal_detector_value_5678.
 *
 * All signal values are as on the CAN bus.
 */
struct can_metal_detector_value_5678_t {
    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t channel_5;

    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t channel_6;

    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t channel_7;

    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t channel_8;
};

/**
 * Signals in message metal_detector_estimated_position.
 *
 * All signal values are as on the CAN bus.
 */
struct can_metal_detector_estimated_position_t {
    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t z;
};

/**
 * Signals in message odrive_left_heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_left_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_status;
};

/**
 * Signals in message odrive_left_estop.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_left_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message odrive_left_get_motor_error.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_left_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message odrive_left_get_encoder_error.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_left_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message odrive_left_set_axis_state.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_left_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message odrive_left_get_encoder_estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_left_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 6.283185307179586
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 6.283185307179586
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message odrive_left_get_encoder_count.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_left_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message odrive_left_set_controller_mode.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_left_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message odrive_left_set_input_pos.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_left_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message odrive_left_set_input_vel.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_left_set_input_vel_t {
    /**
     * Range: -
     * Scale: 6.283185307179586
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_torque_ff;
};

/**
 * Signals in message odrive_left_set_input_torque.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_left_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float imput_torque;
};

/**
 * Signals in message odrive_left_set_limits.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_left_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message odrive_left_get_vbus_voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_left_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message odrive_left_clear_errors.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_left_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message odrive_right_heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_right_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_status;
};

/**
 * Signals in message odrive_right_estop.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_right_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message odrive_right_get_motor_error.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_right_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message odrive_right_get_encoder_error.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_right_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message odrive_right_set_axis_state.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_right_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message odrive_right_get_encoder_estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_right_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 6.283185307179586
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 6.283185307179586
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message odrive_right_get_encoder_count.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_right_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message odrive_right_set_controller_mode.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_right_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message odrive_right_set_input_pos.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_right_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message odrive_right_set_input_vel.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_right_set_input_vel_t {
    /**
     * Range: -
     * Scale: 6.283185307179586
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_torque_ff;
};

/**
 * Signals in message odrive_right_set_input_torque.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_right_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float imput_torque;
};

/**
 * Signals in message odrive_right_set_limits.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_right_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message odrive_right_get_vbus_voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_right_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message odrive_right_clear_errors.
 *
 * All signal values are as on the CAN bus.
 */
struct can_odrive_right_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message temperature_imu_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_imu_status_t {
    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t accelerometer;
};

/**
 * Signals in message temperature_imu_temperature.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_imu_temperature_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t accelerometer;
};

/**
 * Signals in message temperature_imu_warnings.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_imu_warnings_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t accelerometer_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t accelerometer_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t accelerometer_critical_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t accelerometer_critical_under;
};

/**
 * Signals in message temperature_external_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_external_status_t {
    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_1;

    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_2;

    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_3;

    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_4;
};

/**
 * Signals in message temperature_external_temperature.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_external_temperature_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t external_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t external_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t external_3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t external_4;
};

/**
 * Signals in message temperature_external_warnings.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_external_warnings_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_1_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_1_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_1_critical_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_1_critical_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_2_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_2_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_2_critical_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_2_critical_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_3_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_3_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_3_critical_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_3_critical_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_4_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_4_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_4_critical_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_4_critical_under;
};

/**
 * Signals in message temperature_sensor_board_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_sensor_board_status_t {
    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller;

    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ambient;

    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ldo;
};

/**
 * Signals in message temperature_sensor_board_temperature.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_sensor_board_temperature_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ucontroller;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ambient;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ldo;
};

/**
 * Signals in message temperature_sensor_board_warnings.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_sensor_board_warnings_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller_critical_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller_critical_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ambient_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ambient_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ambient_critical_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ambient_critical_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ldo_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ldo_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ldo_critical_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ldo_critical_under;
};

/**
 * Signals in message temperature_power_board_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_power_board_status_t {
    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller;

    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ambient;

    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mosfets;
};

/**
 * Signals in message temperature_power_board_temperature.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_power_board_temperature_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ucontroller;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ambient;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t mosfets;
};

/**
 * Signals in message temperature_power_board_warnings.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_power_board_warnings_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller_critical_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller_critical_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ambient_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ambient_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ambient_critical_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ambient_critical_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mosfets_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mosfets_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mosfets_critical_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mosfets_critical_under;
};

/**
 * Signals in message temperature_metal_detector_board_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_metal_detector_board_status_t {
    /**
     * Range: 1..3 (1..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller;
};

/**
 * Signals in message temperature_metal_detector_board_temperature.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_metal_detector_board_temperature_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ucontroller;
};

/**
 * Signals in message temperature_metal_detector_board_warnings.
 *
 * All signal values are as on the CAN bus.
 */
struct can_temperature_metal_detector_board_warnings_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller_under;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller_critical_over;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ucontroller_critical_under;
};

/**
 * Signals in message konarm_1_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_konarm_1_status_t {
    /**
     * Range: 1..4 (1..4 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t status;
};

/**
 * Signals in message konarm_1_set_pos.
 *
 * All signal values are as on the CAN bus.
 */
struct can_konarm_1_set_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float position;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity;
};

/**
 * Signals in message konarm_1_get_pos.
 *
 * All signal values are as on the CAN bus.
 */
struct can_konarm_1_get_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float position;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity;
};

/**
 * Signals in message konarm_1_clear_errors.
 *
 * All signal values are as on the CAN bus.
 */
struct can_konarm_1_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message konarm_2_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_konarm_2_status_t {
    /**
     * Range: 1..4 (1..4 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t status;
};

/**
 * Signals in message konarm_2_set_pos.
 *
 * All signal values are as on the CAN bus.
 */
struct can_konarm_2_set_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float position;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity;
};

/**
 * Signals in message konarm_2_get_pos.
 *
 * All signal values are as on the CAN bus.
 */
struct can_konarm_2_get_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float position;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity;
};

/**
 * Signals in message konarm_2_clear_errors.
 *
 * All signal values are as on the CAN bus.
 */
struct can_konarm_2_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message konarm_3_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_konarm_3_status_t {
    /**
     * Range: 1..4 (1..4 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t status;
};

/**
 * Signals in message konarm_3_set_pos.
 *
 * All signal values are as on the CAN bus.
 */
struct can_konarm_3_set_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float position;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity;
};

/**
 * Signals in message konarm_3_get_pos.
 *
 * All signal values are as on the CAN bus.
 */
struct can_konarm_3_get_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float position;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity;
};

/**
 * Signals in message konarm_3_clear_errors.
 *
 * All signal values are as on the CAN bus.
 */
struct can_konarm_3_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Pack message actuators_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_actuators_status_pack(
    uint8_t *dst_p,
    const struct can_actuators_status_t *src_p,
    size_t size);

/**
 * Unpack message actuators_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_actuators_status_unpack(
    struct can_actuators_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_status_light1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_status_light1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_status_light1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_status_light2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_status_light2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_status_light2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_status_light3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_status_light3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_status_light3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_status_light4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_status_light4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_status_light4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_status_horn_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_status_horn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_status_horn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_status_fan_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_status_fan_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_status_fan_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_status_magnet_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_status_magnet_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_status_magnet_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_status_servos_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_status_servos_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_status_servos_is_in_range(uint8_t value);

/**
 * Pack message actuators_set.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_actuators_set_pack(
    uint8_t *dst_p,
    const struct can_actuators_set_t *src_p,
    size_t size);

/**
 * Unpack message actuators_set.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_actuators_set_unpack(
    struct can_actuators_set_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_set_light1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_set_light1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_set_light1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_set_light2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_set_light2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_set_light2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_set_light3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_set_light3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_set_light3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_set_light4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_set_light4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_set_light4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_set_horn_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_set_horn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_set_horn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_set_fan_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_set_fan_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_set_fan_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_set_magnet_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_set_magnet_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_set_magnet_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_set_servos_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_set_servos_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_set_servos_is_in_range(uint8_t value);

/**
 * Pack message actuators_reset.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_actuators_reset_pack(
    uint8_t *dst_p,
    const struct can_actuators_reset_t *src_p,
    size_t size);

/**
 * Unpack message actuators_reset.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_actuators_reset_unpack(
    struct can_actuators_reset_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_reset_light1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_reset_light1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_reset_light1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_reset_light2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_reset_light2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_reset_light2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_reset_light3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_reset_light3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_reset_light3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_reset_light4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_reset_light4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_reset_light4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_reset_horn_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_reset_horn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_reset_horn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_reset_fan_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_reset_fan_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_reset_fan_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_reset_magnet_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_reset_magnet_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_reset_magnet_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_actuators_reset_servos_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_actuators_reset_servos_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_actuators_reset_servos_is_in_range(uint8_t value);

/**
 * Pack message battery_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_battery_status_pack(
    uint8_t *dst_p,
    const struct can_battery_status_t *src_p,
    size_t size);

/**
 * Unpack message battery_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_battery_status_unpack(
    struct can_battery_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_battery_status_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_battery_status_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_battery_status_status_is_in_range(uint8_t value);

/**
 * Pack message battery_estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_battery_estimates_pack(
    uint8_t *dst_p,
    const struct can_battery_estimates_t *src_p,
    size_t size);

/**
 * Unpack message battery_estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_battery_estimates_unpack(
    struct can_battery_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_battery_estimates_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_battery_estimates_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_battery_estimates_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_battery_estimates_fill_level_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_battery_estimates_fill_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_battery_estimates_fill_level_is_in_range(uint8_t value);

/**
 * Pack message battery_overvoltage_warning.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_battery_overvoltage_warning_pack(
    uint8_t *dst_p,
    const struct can_battery_overvoltage_warning_t *src_p,
    size_t size);

/**
 * Unpack message battery_overvoltage_warning.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_battery_overvoltage_warning_unpack(
    struct can_battery_overvoltage_warning_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_battery_overvoltage_warning_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_battery_overvoltage_warning_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_battery_overvoltage_warning_voltage_is_in_range(uint16_t value);

/**
 * Pack message battery_undervoltage_warning.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_battery_undervoltage_warning_pack(
    uint8_t *dst_p,
    const struct can_battery_undervoltage_warning_t *src_p,
    size_t size);

/**
 * Unpack message battery_undervoltage_warning.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_battery_undervoltage_warning_unpack(
    struct can_battery_undervoltage_warning_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_battery_undervoltage_warning_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_battery_undervoltage_warning_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_battery_undervoltage_warning_voltage_is_in_range(uint16_t value);

/**
 * Pack message buzzer_beep.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_buzzer_beep_pack(
    uint8_t *dst_p,
    const struct can_buzzer_beep_t *src_p,
    size_t size);

/**
 * Unpack message buzzer_beep.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_buzzer_beep_unpack(
    struct can_buzzer_beep_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message buzzer_play_note.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_buzzer_play_note_pack(
    uint8_t *dst_p,
    const struct can_buzzer_play_note_t *src_p,
    size_t size);

/**
 * Unpack message buzzer_play_note.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_buzzer_play_note_unpack(
    struct can_buzzer_play_note_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_buzzer_play_note_frequency_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_buzzer_play_note_frequency_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_buzzer_play_note_frequency_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_buzzer_play_note_duration_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_buzzer_play_note_duration_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_buzzer_play_note_duration_is_in_range(uint16_t value);

/**
 * Pack message buzzer_start.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_buzzer_start_pack(
    uint8_t *dst_p,
    const struct can_buzzer_start_t *src_p,
    size_t size);

/**
 * Unpack message buzzer_start.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_buzzer_start_unpack(
    struct can_buzzer_start_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_buzzer_start_frequency_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_buzzer_start_frequency_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_buzzer_start_frequency_is_in_range(uint16_t value);

/**
 * Pack message buzzer_stop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_buzzer_stop_pack(
    uint8_t *dst_p,
    const struct can_buzzer_stop_t *src_p,
    size_t size);

/**
 * Unpack message buzzer_stop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_buzzer_stop_unpack(
    struct can_buzzer_stop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message control_mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_control_mode_pack(
    uint8_t *dst_p,
    const struct can_control_mode_t *src_p,
    size_t size);

/**
 * Unpack message control_mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_control_mode_unpack(
    struct can_control_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_control_mode_mode_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_control_mode_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_control_mode_mode_is_in_range(uint8_t value);

/**
 * Pack message gps_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_gps_status_pack(
    uint8_t *dst_p,
    const struct can_gps_status_t *src_p,
    size_t size);

/**
 * Unpack message gps_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_gps_status_unpack(
    struct can_gps_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_gps_status_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_gps_status_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_gps_status_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_gps_status_signal_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_gps_status_signal_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_gps_status_signal_is_in_range(int8_t value);

/**
 * Pack message gps_latitude.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_gps_latitude_pack(
    uint8_t *dst_p,
    const struct can_gps_latitude_t *src_p,
    size_t size);

/**
 * Unpack message gps_latitude.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_gps_latitude_unpack(
    struct can_gps_latitude_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double can_gps_latitude_latitude_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_gps_latitude_latitude_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_gps_latitude_latitude_is_in_range(double value);

/**
 * Pack message gps_longitude.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_gps_longitude_pack(
    uint8_t *dst_p,
    const struct can_gps_longitude_t *src_p,
    size_t size);

/**
 * Unpack message gps_longitude.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_gps_longitude_unpack(
    struct can_gps_longitude_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double can_gps_longitude_longitude_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_gps_longitude_longitude_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_gps_longitude_longitude_is_in_range(double value);

/**
 * Pack message gps_date.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_gps_date_pack(
    uint8_t *dst_p,
    const struct can_gps_date_t *src_p,
    size_t size);

/**
 * Unpack message gps_date.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_gps_date_unpack(
    struct can_gps_date_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_gps_date_year_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_gps_date_year_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_gps_date_year_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_gps_date_month_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_gps_date_month_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_gps_date_month_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_gps_date_day_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_gps_date_day_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_gps_date_day_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_gps_date_hour_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_gps_date_hour_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_gps_date_hour_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_gps_date_minute_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_gps_date_minute_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_gps_date_minute_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_gps_date_second_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_gps_date_second_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_gps_date_second_is_in_range(uint8_t value);

/**
 * Pack message imu_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_imu_status_pack(
    uint8_t *dst_p,
    const struct can_imu_status_t *src_p,
    size_t size);

/**
 * Unpack message imu_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_imu_status_unpack(
    struct can_imu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_imu_status_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_imu_status_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_imu_status_status_is_in_range(uint8_t value);

/**
 * Pack message imu_orientation.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_imu_orientation_pack(
    uint8_t *dst_p,
    const struct can_imu_orientation_t *src_p,
    size_t size);

/**
 * Unpack message imu_orientation.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_imu_orientation_unpack(
    struct can_imu_orientation_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_imu_orientation_w_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_imu_orientation_w_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_imu_orientation_w_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_imu_orientation_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_imu_orientation_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_imu_orientation_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_imu_orientation_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_imu_orientation_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_imu_orientation_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_imu_orientation_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_imu_orientation_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_imu_orientation_z_is_in_range(int16_t value);

/**
 * Pack message imu_linear_acceleration.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_imu_linear_acceleration_pack(
    uint8_t *dst_p,
    const struct can_imu_linear_acceleration_t *src_p,
    size_t size);

/**
 * Unpack message imu_linear_acceleration.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_imu_linear_acceleration_unpack(
    struct can_imu_linear_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_imu_linear_acceleration_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_imu_linear_acceleration_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_imu_linear_acceleration_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_imu_linear_acceleration_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_imu_linear_acceleration_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_imu_linear_acceleration_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_imu_linear_acceleration_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_imu_linear_acceleration_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_imu_linear_acceleration_z_is_in_range(int16_t value);

/**
 * Pack message imu_magnetic_field.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_imu_magnetic_field_pack(
    uint8_t *dst_p,
    const struct can_imu_magnetic_field_t *src_p,
    size_t size);

/**
 * Unpack message imu_magnetic_field.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_imu_magnetic_field_unpack(
    struct can_imu_magnetic_field_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_imu_magnetic_field_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_imu_magnetic_field_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_imu_magnetic_field_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_imu_magnetic_field_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_imu_magnetic_field_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_imu_magnetic_field_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_imu_magnetic_field_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_imu_magnetic_field_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_imu_magnetic_field_z_is_in_range(int16_t value);

/**
 * Pack message imu_gyration.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_imu_gyration_pack(
    uint8_t *dst_p,
    const struct can_imu_gyration_t *src_p,
    size_t size);

/**
 * Unpack message imu_gyration.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_imu_gyration_unpack(
    struct can_imu_gyration_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_imu_gyration_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_imu_gyration_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_imu_gyration_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_imu_gyration_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_imu_gyration_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_imu_gyration_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_imu_gyration_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_imu_gyration_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_imu_gyration_z_is_in_range(int16_t value);

/**
 * Pack message metal_detector_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_metal_detector_status_pack(
    uint8_t *dst_p,
    const struct can_metal_detector_status_t *src_p,
    size_t size);

/**
 * Unpack message metal_detector_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_metal_detector_status_unpack(
    struct can_metal_detector_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_metal_detector_status_channel_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_status_channel_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_status_channel_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_metal_detector_status_channel_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_status_channel_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_status_channel_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_metal_detector_status_channel_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_status_channel_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_status_channel_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_metal_detector_status_channel_4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_status_channel_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_status_channel_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_metal_detector_status_channel_5_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_status_channel_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_status_channel_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_metal_detector_status_channel_6_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_status_channel_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_status_channel_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_metal_detector_status_channel_7_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_status_channel_7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_status_channel_7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_metal_detector_status_channel_8_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_status_channel_8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_status_channel_8_is_in_range(uint8_t value);

/**
 * Pack message metal_detector_value_1234.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_metal_detector_value_1234_pack(
    uint8_t *dst_p,
    const struct can_metal_detector_value_1234_t *src_p,
    size_t size);

/**
 * Unpack message metal_detector_value_1234.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_metal_detector_value_1234_unpack(
    struct can_metal_detector_value_1234_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_metal_detector_value_1234_channel_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_value_1234_channel_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_value_1234_channel_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_metal_detector_value_1234_channel_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_value_1234_channel_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_value_1234_channel_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_metal_detector_value_1234_channel_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_value_1234_channel_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_value_1234_channel_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_metal_detector_value_1234_channel_4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_value_1234_channel_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_value_1234_channel_4_is_in_range(uint16_t value);

/**
 * Pack message metal_detector_value_5678.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_metal_detector_value_5678_pack(
    uint8_t *dst_p,
    const struct can_metal_detector_value_5678_t *src_p,
    size_t size);

/**
 * Unpack message metal_detector_value_5678.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_metal_detector_value_5678_unpack(
    struct can_metal_detector_value_5678_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_metal_detector_value_5678_channel_5_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_value_5678_channel_5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_value_5678_channel_5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_metal_detector_value_5678_channel_6_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_value_5678_channel_6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_value_5678_channel_6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_metal_detector_value_5678_channel_7_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_value_5678_channel_7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_value_5678_channel_7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_metal_detector_value_5678_channel_8_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_value_5678_channel_8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_value_5678_channel_8_is_in_range(uint16_t value);

/**
 * Pack message metal_detector_estimated_position.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_metal_detector_estimated_position_pack(
    uint8_t *dst_p,
    const struct can_metal_detector_estimated_position_t *src_p,
    size_t size);

/**
 * Unpack message metal_detector_estimated_position.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_metal_detector_estimated_position_unpack(
    struct can_metal_detector_estimated_position_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_metal_detector_estimated_position_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_estimated_position_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_estimated_position_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_metal_detector_estimated_position_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_estimated_position_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_estimated_position_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_metal_detector_estimated_position_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_metal_detector_estimated_position_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_metal_detector_estimated_position_z_is_in_range(int16_t value);

/**
 * Pack message odrive_left_heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_left_heartbeat_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message odrive_left_heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_left_heartbeat_unpack(
    struct can_odrive_left_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_left_heartbeat_axis_error_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_odrive_left_heartbeat_axis_state_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_odrive_left_heartbeat_controller_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_heartbeat_controller_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_heartbeat_controller_status_is_in_range(uint8_t value);

/**
 * Pack message odrive_left_estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_left_estop_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_estop_t *src_p,
    size_t size);

/**
 * Unpack message odrive_left_estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_left_estop_unpack(
    struct can_odrive_left_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message odrive_left_get_motor_error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_left_get_motor_error_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message odrive_left_get_motor_error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_left_get_motor_error_unpack(
    struct can_odrive_left_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_left_get_motor_error_motor_error_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message odrive_left_get_encoder_error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_left_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message odrive_left_get_encoder_error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_left_get_encoder_error_unpack(
    struct can_odrive_left_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_left_get_encoder_error_encoder_error_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message odrive_left_set_axis_state.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_left_set_axis_state_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message odrive_left_set_axis_state.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_left_set_axis_state_unpack(
    struct can_odrive_left_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_left_set_axis_state_axis_requested_state_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message odrive_left_get_encoder_estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_left_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message odrive_left_get_encoder_estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_left_get_encoder_estimates_unpack(
    struct can_odrive_left_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_left_get_encoder_estimates_pos_estimate_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_left_get_encoder_estimates_vel_estimate_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message odrive_left_get_encoder_count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_left_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message odrive_left_get_encoder_count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_left_get_encoder_count_unpack(
    struct can_odrive_left_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_left_get_encoder_count_shadow_count_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_left_get_encoder_count_count_in_cpr_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message odrive_left_set_controller_mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_left_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message odrive_left_set_controller_mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_left_set_controller_mode_unpack(
    struct can_odrive_left_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_left_set_controller_mode_control_mode_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_left_set_controller_mode_input_mode_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message odrive_left_set_input_pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_left_set_input_pos_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message odrive_left_set_input_pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_left_set_input_pos_unpack(
    struct can_odrive_left_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_left_set_input_pos_input_pos_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_odrive_left_set_input_pos_vel_ff_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_odrive_left_set_input_pos_torque_ff_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message odrive_left_set_input_vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_left_set_input_vel_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message odrive_left_set_input_vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_left_set_input_vel_unpack(
    struct can_odrive_left_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_left_set_input_vel_input_vel_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_left_set_input_vel_input_torque_ff_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_set_input_vel_input_torque_ff_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_set_input_vel_input_torque_ff_is_in_range(uint32_t value);

/**
 * Pack message odrive_left_set_input_torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_left_set_input_torque_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message odrive_left_set_input_torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_left_set_input_torque_unpack(
    struct can_odrive_left_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_left_set_input_torque_imput_torque_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_set_input_torque_imput_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_set_input_torque_imput_torque_is_in_range(float value);

/**
 * Pack message odrive_left_set_limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_left_set_limits_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message odrive_left_set_limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_left_set_limits_unpack(
    struct can_odrive_left_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_left_set_limits_velocity_limit_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_left_set_limits_current_limit_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message odrive_left_get_vbus_voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_left_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message odrive_left_get_vbus_voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_left_get_vbus_voltage_unpack(
    struct can_odrive_left_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_left_get_vbus_voltage_vbus_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_left_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_left_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message odrive_left_clear_errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_left_clear_errors_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message odrive_left_clear_errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_left_clear_errors_unpack(
    struct can_odrive_left_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message odrive_right_heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_right_heartbeat_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message odrive_right_heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_right_heartbeat_unpack(
    struct can_odrive_right_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_right_heartbeat_axis_error_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_odrive_right_heartbeat_axis_state_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_odrive_right_heartbeat_controller_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_heartbeat_controller_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_heartbeat_controller_status_is_in_range(uint8_t value);

/**
 * Pack message odrive_right_estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_right_estop_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_estop_t *src_p,
    size_t size);

/**
 * Unpack message odrive_right_estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_right_estop_unpack(
    struct can_odrive_right_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message odrive_right_get_motor_error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_right_get_motor_error_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message odrive_right_get_motor_error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_right_get_motor_error_unpack(
    struct can_odrive_right_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_right_get_motor_error_motor_error_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message odrive_right_get_encoder_error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_right_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message odrive_right_get_encoder_error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_right_get_encoder_error_unpack(
    struct can_odrive_right_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_right_get_encoder_error_encoder_error_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message odrive_right_set_axis_state.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_right_set_axis_state_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message odrive_right_set_axis_state.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_right_set_axis_state_unpack(
    struct can_odrive_right_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_right_set_axis_state_axis_requested_state_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message odrive_right_get_encoder_estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_right_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message odrive_right_get_encoder_estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_right_get_encoder_estimates_unpack(
    struct can_odrive_right_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_right_get_encoder_estimates_pos_estimate_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_right_get_encoder_estimates_vel_estimate_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message odrive_right_get_encoder_count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_right_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message odrive_right_get_encoder_count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_right_get_encoder_count_unpack(
    struct can_odrive_right_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_right_get_encoder_count_shadow_count_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_right_get_encoder_count_count_in_cpr_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message odrive_right_set_controller_mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_right_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message odrive_right_set_controller_mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_right_set_controller_mode_unpack(
    struct can_odrive_right_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_right_set_controller_mode_control_mode_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_right_set_controller_mode_input_mode_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message odrive_right_set_input_pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_right_set_input_pos_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message odrive_right_set_input_pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_right_set_input_pos_unpack(
    struct can_odrive_right_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_right_set_input_pos_input_pos_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_odrive_right_set_input_pos_vel_ff_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_odrive_right_set_input_pos_torque_ff_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message odrive_right_set_input_vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_right_set_input_vel_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message odrive_right_set_input_vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_right_set_input_vel_unpack(
    struct can_odrive_right_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_right_set_input_vel_input_vel_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_odrive_right_set_input_vel_input_torque_ff_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_set_input_vel_input_torque_ff_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_set_input_vel_input_torque_ff_is_in_range(uint32_t value);

/**
 * Pack message odrive_right_set_input_torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_right_set_input_torque_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message odrive_right_set_input_torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_right_set_input_torque_unpack(
    struct can_odrive_right_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_right_set_input_torque_imput_torque_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_set_input_torque_imput_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_set_input_torque_imput_torque_is_in_range(float value);

/**
 * Pack message odrive_right_set_limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_right_set_limits_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message odrive_right_set_limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_right_set_limits_unpack(
    struct can_odrive_right_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_right_set_limits_velocity_limit_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_right_set_limits_current_limit_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message odrive_right_get_vbus_voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_right_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message odrive_right_get_vbus_voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_right_get_vbus_voltage_unpack(
    struct can_odrive_right_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_odrive_right_get_vbus_voltage_vbus_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_odrive_right_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_odrive_right_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message odrive_right_clear_errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_odrive_right_clear_errors_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message odrive_right_clear_errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_odrive_right_clear_errors_unpack(
    struct can_odrive_right_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message temperature_imu_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_imu_status_pack(
    uint8_t *dst_p,
    const struct can_temperature_imu_status_t *src_p,
    size_t size);

/**
 * Unpack message temperature_imu_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_imu_status_unpack(
    struct can_temperature_imu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_imu_status_accelerometer_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_imu_status_accelerometer_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_imu_status_accelerometer_is_in_range(uint8_t value);

/**
 * Pack message temperature_imu_temperature.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_imu_temperature_pack(
    uint8_t *dst_p,
    const struct can_temperature_imu_temperature_t *src_p,
    size_t size);

/**
 * Unpack message temperature_imu_temperature.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_imu_temperature_unpack(
    struct can_temperature_imu_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_temperature_imu_temperature_accelerometer_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_imu_temperature_accelerometer_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_imu_temperature_accelerometer_is_in_range(int8_t value);

/**
 * Pack message temperature_imu_warnings.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_imu_warnings_pack(
    uint8_t *dst_p,
    const struct can_temperature_imu_warnings_t *src_p,
    size_t size);

/**
 * Unpack message temperature_imu_warnings.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_imu_warnings_unpack(
    struct can_temperature_imu_warnings_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_imu_warnings_accelerometer_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_imu_warnings_accelerometer_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_imu_warnings_accelerometer_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_imu_warnings_accelerometer_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_imu_warnings_accelerometer_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_imu_warnings_accelerometer_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_imu_warnings_accelerometer_critical_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_imu_warnings_accelerometer_critical_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_imu_warnings_accelerometer_critical_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_imu_warnings_accelerometer_critical_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_imu_warnings_accelerometer_critical_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_imu_warnings_accelerometer_critical_under_is_in_range(uint8_t value);

/**
 * Pack message temperature_external_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_external_status_pack(
    uint8_t *dst_p,
    const struct can_temperature_external_status_t *src_p,
    size_t size);

/**
 * Unpack message temperature_external_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_external_status_unpack(
    struct can_temperature_external_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_status_external_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_status_external_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_status_external_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_status_external_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_status_external_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_status_external_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_status_external_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_status_external_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_status_external_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_status_external_4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_status_external_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_status_external_4_is_in_range(uint8_t value);

/**
 * Pack message temperature_external_temperature.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_external_temperature_pack(
    uint8_t *dst_p,
    const struct can_temperature_external_temperature_t *src_p,
    size_t size);

/**
 * Unpack message temperature_external_temperature.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_external_temperature_unpack(
    struct can_temperature_external_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_temperature_external_temperature_external_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_temperature_external_1_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_temperature_external_1_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_temperature_external_temperature_external_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_temperature_external_2_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_temperature_external_2_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_temperature_external_temperature_external_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_temperature_external_3_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_temperature_external_3_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_temperature_external_temperature_external_4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_temperature_external_4_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_temperature_external_4_is_in_range(int8_t value);

/**
 * Pack message temperature_external_warnings.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_external_warnings_pack(
    uint8_t *dst_p,
    const struct can_temperature_external_warnings_t *src_p,
    size_t size);

/**
 * Unpack message temperature_external_warnings.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_external_warnings_unpack(
    struct can_temperature_external_warnings_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_1_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_1_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_1_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_1_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_1_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_1_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_1_critical_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_1_critical_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_1_critical_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_1_critical_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_1_critical_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_1_critical_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_2_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_2_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_2_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_2_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_2_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_2_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_2_critical_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_2_critical_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_2_critical_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_2_critical_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_2_critical_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_2_critical_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_3_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_3_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_3_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_3_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_3_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_3_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_3_critical_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_3_critical_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_3_critical_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_3_critical_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_3_critical_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_3_critical_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_4_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_4_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_4_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_4_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_4_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_4_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_4_critical_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_4_critical_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_4_critical_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_external_warnings_external_4_critical_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_external_warnings_external_4_critical_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_external_warnings_external_4_critical_under_is_in_range(uint8_t value);

/**
 * Pack message temperature_sensor_board_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_sensor_board_status_pack(
    uint8_t *dst_p,
    const struct can_temperature_sensor_board_status_t *src_p,
    size_t size);

/**
 * Unpack message temperature_sensor_board_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_sensor_board_status_unpack(
    struct can_temperature_sensor_board_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_status_ucontroller_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_status_ucontroller_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_status_ucontroller_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_status_ambient_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_status_ambient_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_status_ambient_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_status_ldo_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_status_ldo_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_status_ldo_is_in_range(uint8_t value);

/**
 * Pack message temperature_sensor_board_temperature.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_sensor_board_temperature_pack(
    uint8_t *dst_p,
    const struct can_temperature_sensor_board_temperature_t *src_p,
    size_t size);

/**
 * Unpack message temperature_sensor_board_temperature.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_sensor_board_temperature_unpack(
    struct can_temperature_sensor_board_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_temperature_sensor_board_temperature_ucontroller_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_temperature_ucontroller_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_temperature_ucontroller_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_temperature_sensor_board_temperature_ambient_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_temperature_ambient_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_temperature_ambient_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_temperature_sensor_board_temperature_ldo_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_temperature_ldo_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_temperature_ldo_is_in_range(int8_t value);

/**
 * Pack message temperature_sensor_board_warnings.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_sensor_board_warnings_pack(
    uint8_t *dst_p,
    const struct can_temperature_sensor_board_warnings_t *src_p,
    size_t size);

/**
 * Unpack message temperature_sensor_board_warnings.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_sensor_board_warnings_unpack(
    struct can_temperature_sensor_board_warnings_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_warnings_ucontroller_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_warnings_ucontroller_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_warnings_ucontroller_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_warnings_ucontroller_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_warnings_ucontroller_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_warnings_ucontroller_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_warnings_ucontroller_critical_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_warnings_ucontroller_critical_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_warnings_ucontroller_critical_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_warnings_ucontroller_critical_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_warnings_ucontroller_critical_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_warnings_ucontroller_critical_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_warnings_ambient_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_warnings_ambient_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_warnings_ambient_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_warnings_ambient_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_warnings_ambient_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_warnings_ambient_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_warnings_ambient_critical_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_warnings_ambient_critical_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_warnings_ambient_critical_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_warnings_ambient_critical_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_warnings_ambient_critical_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_warnings_ambient_critical_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_warnings_ldo_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_warnings_ldo_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_warnings_ldo_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_warnings_ldo_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_warnings_ldo_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_warnings_ldo_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_warnings_ldo_critical_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_warnings_ldo_critical_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_warnings_ldo_critical_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_sensor_board_warnings_ldo_critical_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_sensor_board_warnings_ldo_critical_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_sensor_board_warnings_ldo_critical_under_is_in_range(uint8_t value);

/**
 * Pack message temperature_power_board_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_power_board_status_pack(
    uint8_t *dst_p,
    const struct can_temperature_power_board_status_t *src_p,
    size_t size);

/**
 * Unpack message temperature_power_board_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_power_board_status_unpack(
    struct can_temperature_power_board_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_status_ucontroller_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_status_ucontroller_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_status_ucontroller_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_status_ambient_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_status_ambient_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_status_ambient_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_status_mosfets_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_status_mosfets_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_status_mosfets_is_in_range(uint8_t value);

/**
 * Pack message temperature_power_board_temperature.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_power_board_temperature_pack(
    uint8_t *dst_p,
    const struct can_temperature_power_board_temperature_t *src_p,
    size_t size);

/**
 * Unpack message temperature_power_board_temperature.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_power_board_temperature_unpack(
    struct can_temperature_power_board_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_temperature_power_board_temperature_ucontroller_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_temperature_ucontroller_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_temperature_ucontroller_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_temperature_power_board_temperature_ambient_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_temperature_ambient_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_temperature_ambient_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_temperature_power_board_temperature_mosfets_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_temperature_mosfets_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_temperature_mosfets_is_in_range(int8_t value);

/**
 * Pack message temperature_power_board_warnings.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_power_board_warnings_pack(
    uint8_t *dst_p,
    const struct can_temperature_power_board_warnings_t *src_p,
    size_t size);

/**
 * Unpack message temperature_power_board_warnings.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_power_board_warnings_unpack(
    struct can_temperature_power_board_warnings_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_warnings_ucontroller_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_warnings_ucontroller_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_warnings_ucontroller_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_warnings_ucontroller_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_warnings_ucontroller_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_warnings_ucontroller_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_warnings_ucontroller_critical_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_warnings_ucontroller_critical_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_warnings_ucontroller_critical_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_warnings_ucontroller_critical_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_warnings_ucontroller_critical_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_warnings_ucontroller_critical_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_warnings_ambient_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_warnings_ambient_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_warnings_ambient_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_warnings_ambient_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_warnings_ambient_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_warnings_ambient_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_warnings_ambient_critical_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_warnings_ambient_critical_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_warnings_ambient_critical_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_warnings_ambient_critical_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_warnings_ambient_critical_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_warnings_ambient_critical_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_warnings_mosfets_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_warnings_mosfets_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_warnings_mosfets_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_warnings_mosfets_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_warnings_mosfets_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_warnings_mosfets_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_warnings_mosfets_critical_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_warnings_mosfets_critical_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_warnings_mosfets_critical_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_power_board_warnings_mosfets_critical_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_power_board_warnings_mosfets_critical_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_power_board_warnings_mosfets_critical_under_is_in_range(uint8_t value);

/**
 * Pack message temperature_metal_detector_board_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_metal_detector_board_status_pack(
    uint8_t *dst_p,
    const struct can_temperature_metal_detector_board_status_t *src_p,
    size_t size);

/**
 * Unpack message temperature_metal_detector_board_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_metal_detector_board_status_unpack(
    struct can_temperature_metal_detector_board_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_metal_detector_board_status_ucontroller_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_metal_detector_board_status_ucontroller_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_metal_detector_board_status_ucontroller_is_in_range(uint8_t value);

/**
 * Pack message temperature_metal_detector_board_temperature.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_metal_detector_board_temperature_pack(
    uint8_t *dst_p,
    const struct can_temperature_metal_detector_board_temperature_t *src_p,
    size_t size);

/**
 * Unpack message temperature_metal_detector_board_temperature.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_metal_detector_board_temperature_unpack(
    struct can_temperature_metal_detector_board_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_temperature_metal_detector_board_temperature_ucontroller_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_metal_detector_board_temperature_ucontroller_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_metal_detector_board_temperature_ucontroller_is_in_range(int8_t value);

/**
 * Pack message temperature_metal_detector_board_warnings.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_temperature_metal_detector_board_warnings_pack(
    uint8_t *dst_p,
    const struct can_temperature_metal_detector_board_warnings_t *src_p,
    size_t size);

/**
 * Unpack message temperature_metal_detector_board_warnings.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_temperature_metal_detector_board_warnings_unpack(
    struct can_temperature_metal_detector_board_warnings_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_metal_detector_board_warnings_ucontroller_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_metal_detector_board_warnings_ucontroller_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_metal_detector_board_warnings_ucontroller_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_metal_detector_board_warnings_ucontroller_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_metal_detector_board_warnings_ucontroller_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_metal_detector_board_warnings_ucontroller_under_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_metal_detector_board_warnings_ucontroller_critical_over_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_metal_detector_board_warnings_ucontroller_critical_over_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_metal_detector_board_warnings_ucontroller_critical_over_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_temperature_metal_detector_board_warnings_ucontroller_critical_under_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_temperature_metal_detector_board_warnings_ucontroller_critical_under_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_temperature_metal_detector_board_warnings_ucontroller_critical_under_is_in_range(uint8_t value);

/**
 * Pack message konarm_1_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_konarm_1_status_pack(
    uint8_t *dst_p,
    const struct can_konarm_1_status_t *src_p,
    size_t size);

/**
 * Unpack message konarm_1_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_konarm_1_status_unpack(
    struct can_konarm_1_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_konarm_1_status_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_1_status_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_1_status_status_is_in_range(uint8_t value);

/**
 * Pack message konarm_1_set_pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_konarm_1_set_pos_pack(
    uint8_t *dst_p,
    const struct can_konarm_1_set_pos_t *src_p,
    size_t size);

/**
 * Unpack message konarm_1_set_pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_konarm_1_set_pos_unpack(
    struct can_konarm_1_set_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_konarm_1_set_pos_position_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_1_set_pos_position_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_1_set_pos_position_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_konarm_1_set_pos_velocity_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_1_set_pos_velocity_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_1_set_pos_velocity_is_in_range(float value);

/**
 * Pack message konarm_1_get_pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_konarm_1_get_pos_pack(
    uint8_t *dst_p,
    const struct can_konarm_1_get_pos_t *src_p,
    size_t size);

/**
 * Unpack message konarm_1_get_pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_konarm_1_get_pos_unpack(
    struct can_konarm_1_get_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_konarm_1_get_pos_position_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_1_get_pos_position_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_1_get_pos_position_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_konarm_1_get_pos_velocity_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_1_get_pos_velocity_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_1_get_pos_velocity_is_in_range(float value);

/**
 * Pack message konarm_1_clear_errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_konarm_1_clear_errors_pack(
    uint8_t *dst_p,
    const struct can_konarm_1_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message konarm_1_clear_errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_konarm_1_clear_errors_unpack(
    struct can_konarm_1_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message konarm_2_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_konarm_2_status_pack(
    uint8_t *dst_p,
    const struct can_konarm_2_status_t *src_p,
    size_t size);

/**
 * Unpack message konarm_2_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_konarm_2_status_unpack(
    struct can_konarm_2_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_konarm_2_status_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_2_status_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_2_status_status_is_in_range(uint8_t value);

/**
 * Pack message konarm_2_set_pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_konarm_2_set_pos_pack(
    uint8_t *dst_p,
    const struct can_konarm_2_set_pos_t *src_p,
    size_t size);

/**
 * Unpack message konarm_2_set_pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_konarm_2_set_pos_unpack(
    struct can_konarm_2_set_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_konarm_2_set_pos_position_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_2_set_pos_position_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_2_set_pos_position_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_konarm_2_set_pos_velocity_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_2_set_pos_velocity_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_2_set_pos_velocity_is_in_range(float value);

/**
 * Pack message konarm_2_get_pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_konarm_2_get_pos_pack(
    uint8_t *dst_p,
    const struct can_konarm_2_get_pos_t *src_p,
    size_t size);

/**
 * Unpack message konarm_2_get_pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_konarm_2_get_pos_unpack(
    struct can_konarm_2_get_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_konarm_2_get_pos_position_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_2_get_pos_position_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_2_get_pos_position_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_konarm_2_get_pos_velocity_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_2_get_pos_velocity_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_2_get_pos_velocity_is_in_range(float value);

/**
 * Pack message konarm_2_clear_errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_konarm_2_clear_errors_pack(
    uint8_t *dst_p,
    const struct can_konarm_2_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message konarm_2_clear_errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_konarm_2_clear_errors_unpack(
    struct can_konarm_2_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message konarm_3_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_konarm_3_status_pack(
    uint8_t *dst_p,
    const struct can_konarm_3_status_t *src_p,
    size_t size);

/**
 * Unpack message konarm_3_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_konarm_3_status_unpack(
    struct can_konarm_3_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_konarm_3_status_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_3_status_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_3_status_status_is_in_range(uint8_t value);

/**
 * Pack message konarm_3_set_pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_konarm_3_set_pos_pack(
    uint8_t *dst_p,
    const struct can_konarm_3_set_pos_t *src_p,
    size_t size);

/**
 * Unpack message konarm_3_set_pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_konarm_3_set_pos_unpack(
    struct can_konarm_3_set_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_konarm_3_set_pos_position_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_3_set_pos_position_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_3_set_pos_position_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_konarm_3_set_pos_velocity_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_3_set_pos_velocity_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_3_set_pos_velocity_is_in_range(float value);

/**
 * Pack message konarm_3_get_pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_konarm_3_get_pos_pack(
    uint8_t *dst_p,
    const struct can_konarm_3_get_pos_t *src_p,
    size_t size);

/**
 * Unpack message konarm_3_get_pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_konarm_3_get_pos_unpack(
    struct can_konarm_3_get_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_konarm_3_get_pos_position_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_3_get_pos_position_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_3_get_pos_position_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_konarm_3_get_pos_velocity_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float can_konarm_3_get_pos_velocity_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_konarm_3_get_pos_velocity_is_in_range(float value);

/**
 * Pack message konarm_3_clear_errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_konarm_3_clear_errors_pack(
    uint8_t *dst_p,
    const struct can_konarm_3_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message konarm_3_clear_errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_konarm_3_clear_errors_unpack(
    struct can_konarm_3_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);


#ifdef __cplusplus
}
#endif

#endif
