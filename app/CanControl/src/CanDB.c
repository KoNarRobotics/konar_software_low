/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Mon Apr 17 13:42:04 2023.
 */

#include <string.h>

#include "CanDB.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u64(
    uint64_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u64(
    uint64_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint64_t unpack_left_shift_u64(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint64_t)((uint64_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

static inline uint64_t unpack_right_shift_u64(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint64_t)((uint64_t)(value & mask) >> shift);
}

int can_actuators_status_pack(
    uint8_t *dst_p,
    const struct can_actuators_status_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->light1, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->light2, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->light3, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->light4, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->horn, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->fan, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->magnet, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->servos, 7u, 0x80u);

    return (1);
}

int can_actuators_status_unpack(
    struct can_actuators_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->light1 = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->light2 = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->light3 = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->light4 = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->horn = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->fan = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->magnet = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->servos = unpack_right_shift_u8(src_p[0], 7u, 0x80u);

    return (0);
}

uint8_t can_actuators_status_light1_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_status_light1_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_status_light1_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_status_light2_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_status_light2_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_status_light2_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_status_light3_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_status_light3_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_status_light3_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_status_light4_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_status_light4_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_status_light4_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_status_horn_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_status_horn_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_status_horn_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_status_fan_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_status_fan_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_status_fan_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_status_magnet_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_status_magnet_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_status_magnet_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_status_servos_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_status_servos_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_status_servos_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_actuators_set_pack(
    uint8_t *dst_p,
    const struct can_actuators_set_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->light1, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->light2, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->light3, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->light4, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->horn, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->fan, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->magnet, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->servos, 7u, 0x80u);

    return (1);
}

int can_actuators_set_unpack(
    struct can_actuators_set_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->light1 = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->light2 = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->light3 = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->light4 = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->horn = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->fan = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->magnet = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->servos = unpack_right_shift_u8(src_p[0], 7u, 0x80u);

    return (0);
}

uint8_t can_actuators_set_light1_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_set_light1_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_set_light1_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_set_light2_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_set_light2_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_set_light2_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_set_light3_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_set_light3_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_set_light3_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_set_light4_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_set_light4_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_set_light4_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_set_horn_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_set_horn_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_set_horn_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_set_fan_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_set_fan_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_set_fan_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_set_magnet_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_set_magnet_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_set_magnet_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_set_servos_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_set_servos_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_set_servos_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_actuators_reset_pack(
    uint8_t *dst_p,
    const struct can_actuators_reset_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->light1, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->light2, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->light3, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->light4, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->horn, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->fan, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->magnet, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->servos, 7u, 0x80u);

    return (1);
}

int can_actuators_reset_unpack(
    struct can_actuators_reset_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->light1 = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->light2 = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->light3 = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->light4 = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->horn = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->fan = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->magnet = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->servos = unpack_right_shift_u8(src_p[0], 7u, 0x80u);

    return (0);
}

uint8_t can_actuators_reset_light1_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_reset_light1_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_reset_light1_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_reset_light2_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_reset_light2_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_reset_light2_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_reset_light3_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_reset_light3_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_reset_light3_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_reset_light4_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_reset_light4_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_reset_light4_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_reset_horn_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_reset_horn_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_reset_horn_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_reset_fan_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_reset_fan_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_reset_fan_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_reset_magnet_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_reset_magnet_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_reset_magnet_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_actuators_reset_servos_encode(float value)
{
    return (uint8_t)(value);
}

float can_actuators_reset_servos_decode(uint8_t value)
{
    return ((float)value);
}

bool can_actuators_reset_servos_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_battery_status_pack(
    uint8_t *dst_p,
    const struct can_battery_status_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->status, 0u, 0xffu);

    return (1);
}

int can_battery_status_unpack(
    struct can_battery_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->status = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t can_battery_status_status_encode(float value)
{
    return (uint8_t)(value);
}

float can_battery_status_status_decode(uint8_t value)
{
    return ((float)value);
}

bool can_battery_status_status_is_in_range(uint8_t value)
{
    return (value <= 4u);
}

int can_battery_estimates_pack(
    uint8_t *dst_p,
    const struct can_battery_estimates_t *src_p,
    size_t size)
{
    if (size < 3u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 3);

    dst_p[0] |= pack_left_shift_u16(src_p->voltage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->voltage, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->fill_level, 0u, 0xffu);

    return (3);
}

int can_battery_estimates_unpack(
    struct can_battery_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 3u)
    {
        return (-EINVAL);
    }

    dst_p->voltage = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->voltage |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fill_level = unpack_right_shift_u8(src_p[2], 0u, 0xffu);

    return (0);
}

uint16_t can_battery_estimates_voltage_encode(float value)
{
    return (uint16_t)(value / 0.001f);
}

float can_battery_estimates_voltage_decode(uint16_t value)
{
    return ((float)value * 0.001f);
}

bool can_battery_estimates_voltage_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_battery_estimates_fill_level_encode(float value)
{
    return (uint8_t)(value);
}

float can_battery_estimates_fill_level_decode(uint8_t value)
{
    return ((float)value);
}

bool can_battery_estimates_fill_level_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

int can_battery_overvoltage_warning_pack(
    uint8_t *dst_p,
    const struct can_battery_overvoltage_warning_t *src_p,
    size_t size)
{
    if (size < 2u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u16(src_p->voltage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->voltage, 8u, 0xffu);

    return (2);
}

int can_battery_overvoltage_warning_unpack(
    struct can_battery_overvoltage_warning_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u)
    {
        return (-EINVAL);
    }

    dst_p->voltage = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->voltage |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    return (0);
}

uint16_t can_battery_overvoltage_warning_voltage_encode(float value)
{
    return (uint16_t)(value / 0.001f);
}

float can_battery_overvoltage_warning_voltage_decode(uint16_t value)
{
    return ((float)value * 0.001f);
}

bool can_battery_overvoltage_warning_voltage_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_battery_undervoltage_warning_pack(
    uint8_t *dst_p,
    const struct can_battery_undervoltage_warning_t *src_p,
    size_t size)
{
    if (size < 2u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u16(src_p->voltage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->voltage, 8u, 0xffu);

    return (2);
}

int can_battery_undervoltage_warning_unpack(
    struct can_battery_undervoltage_warning_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u)
    {
        return (-EINVAL);
    }

    dst_p->voltage = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->voltage |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    return (0);
}

uint16_t can_battery_undervoltage_warning_voltage_encode(float value)
{
    return (uint16_t)(value / 0.001f);
}

float can_battery_undervoltage_warning_voltage_decode(uint16_t value)
{
    return ((float)value * 0.001f);
}

bool can_battery_undervoltage_warning_voltage_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_buzzer_beep_pack(
    uint8_t *dst_p,
    const struct can_buzzer_beep_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_buzzer_beep_unpack(
    struct can_buzzer_beep_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_buzzer_play_note_pack(
    uint8_t *dst_p,
    const struct can_buzzer_play_note_t *src_p,
    size_t size)
{
    if (size < 4u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u16(src_p->frequency, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->frequency, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->duration, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->duration, 8u, 0xffu);

    return (4);
}

int can_buzzer_play_note_unpack(
    struct can_buzzer_play_note_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u)
    {
        return (-EINVAL);
    }

    dst_p->frequency = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->frequency |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->duration = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->duration |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    return (0);
}

uint16_t can_buzzer_play_note_frequency_encode(float value)
{
    return (uint16_t)(value);
}

float can_buzzer_play_note_frequency_decode(uint16_t value)
{
    return ((float)value);
}

bool can_buzzer_play_note_frequency_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_buzzer_play_note_duration_encode(float value)
{
    return (uint16_t)(value);
}

float can_buzzer_play_note_duration_decode(uint16_t value)
{
    return ((float)value);
}

bool can_buzzer_play_note_duration_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_buzzer_start_pack(
    uint8_t *dst_p,
    const struct can_buzzer_start_t *src_p,
    size_t size)
{
    if (size < 2u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u16(src_p->frequency, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->frequency, 8u, 0xffu);

    return (2);
}

int can_buzzer_start_unpack(
    struct can_buzzer_start_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u)
    {
        return (-EINVAL);
    }

    dst_p->frequency = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->frequency |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    return (0);
}

uint16_t can_buzzer_start_frequency_encode(float value)
{
    return (uint16_t)(value);
}

float can_buzzer_start_frequency_decode(uint16_t value)
{
    return ((float)value);
}

bool can_buzzer_start_frequency_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_buzzer_stop_pack(
    uint8_t *dst_p,
    const struct can_buzzer_stop_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_buzzer_stop_unpack(
    struct can_buzzer_stop_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_control_mode_pack(
    uint8_t *dst_p,
    const struct can_control_mode_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->mode, 0u, 0xffu);

    return (1);
}

int can_control_mode_unpack(
    struct can_control_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->mode = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t can_control_mode_mode_encode(float value)
{
    return (uint8_t)(value);
}

float can_control_mode_mode_decode(uint8_t value)
{
    return ((float)value);
}

bool can_control_mode_mode_is_in_range(uint8_t value)
{
    return (value <= 2u);
}

int can_gps_status_pack(
    uint8_t *dst_p,
    const struct can_gps_status_t *src_p,
    size_t size)
{
    uint8_t signal;

    if (size < 2u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u8(src_p->status, 0u, 0xffu);
    signal = (uint8_t)src_p->signal;
    dst_p[1] |= pack_left_shift_u8(signal, 0u, 0xffu);

    return (2);
}

int can_gps_status_unpack(
    struct can_gps_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t signal;

    if (size < 2u)
    {
        return (-EINVAL);
    }

    dst_p->status = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    signal = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->signal = (int8_t)signal;

    return (0);
}

uint8_t can_gps_status_status_encode(float value)
{
    return (uint8_t)(value);
}

float can_gps_status_status_decode(uint8_t value)
{
    return ((float)value);
}

bool can_gps_status_status_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

int8_t can_gps_status_signal_encode(float value)
{
    return (int8_t)(value);
}

float can_gps_status_signal_decode(int8_t value)
{
    return ((float)value);
}

bool can_gps_status_signal_is_in_range(int8_t value)
{
    return ((value >= -1) && (value <= 2));
}

int can_gps_latitude_pack(
    uint8_t *dst_p,
    const struct can_gps_latitude_t *src_p,
    size_t size)
{
    uint64_t latitude;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&latitude, &src_p->latitude, sizeof(latitude));
    dst_p[0] |= pack_left_shift_u64(latitude, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u64(latitude, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u64(latitude, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u64(latitude, 24u, 0xffu);
    dst_p[4] |= pack_right_shift_u64(latitude, 32u, 0xffu);
    dst_p[5] |= pack_right_shift_u64(latitude, 40u, 0xffu);
    dst_p[6] |= pack_right_shift_u64(latitude, 48u, 0xffu);
    dst_p[7] |= pack_right_shift_u64(latitude, 56u, 0xffu);

    return (8);
}

int can_gps_latitude_unpack(
    struct can_gps_latitude_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint64_t latitude;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    latitude = unpack_right_shift_u64(src_p[0], 0u, 0xffu);
    latitude |= unpack_left_shift_u64(src_p[1], 8u, 0xffu);
    latitude |= unpack_left_shift_u64(src_p[2], 16u, 0xffu);
    latitude |= unpack_left_shift_u64(src_p[3], 24u, 0xffu);
    latitude |= unpack_left_shift_u64(src_p[4], 32u, 0xffu);
    latitude |= unpack_left_shift_u64(src_p[5], 40u, 0xffu);
    latitude |= unpack_left_shift_u64(src_p[6], 48u, 0xffu);
    latitude |= unpack_left_shift_u64(src_p[7], 56u, 0xffu);
    memcpy(&dst_p->latitude, &latitude, sizeof(dst_p->latitude));

    return (0);
}

double can_gps_latitude_latitude_encode(float value)
{
    return (double)(value);
}

float can_gps_latitude_latitude_decode(double value)
{
    return ((float)value);
}

bool can_gps_latitude_latitude_is_in_range(double value)
{
    (void)value;

    return (true);
}

int can_gps_longitude_pack(
    uint8_t *dst_p,
    const struct can_gps_longitude_t *src_p,
    size_t size)
{
    uint64_t longitude;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&longitude, &src_p->longitude, sizeof(longitude));
    dst_p[0] |= pack_left_shift_u64(longitude, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u64(longitude, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u64(longitude, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u64(longitude, 24u, 0xffu);
    dst_p[4] |= pack_right_shift_u64(longitude, 32u, 0xffu);
    dst_p[5] |= pack_right_shift_u64(longitude, 40u, 0xffu);
    dst_p[6] |= pack_right_shift_u64(longitude, 48u, 0xffu);
    dst_p[7] |= pack_right_shift_u64(longitude, 56u, 0xffu);

    return (8);
}

int can_gps_longitude_unpack(
    struct can_gps_longitude_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint64_t longitude;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    longitude = unpack_right_shift_u64(src_p[0], 0u, 0xffu);
    longitude |= unpack_left_shift_u64(src_p[1], 8u, 0xffu);
    longitude |= unpack_left_shift_u64(src_p[2], 16u, 0xffu);
    longitude |= unpack_left_shift_u64(src_p[3], 24u, 0xffu);
    longitude |= unpack_left_shift_u64(src_p[4], 32u, 0xffu);
    longitude |= unpack_left_shift_u64(src_p[5], 40u, 0xffu);
    longitude |= unpack_left_shift_u64(src_p[6], 48u, 0xffu);
    longitude |= unpack_left_shift_u64(src_p[7], 56u, 0xffu);
    memcpy(&dst_p->longitude, &longitude, sizeof(dst_p->longitude));

    return (0);
}

double can_gps_longitude_longitude_encode(float value)
{
    return (double)(value);
}

float can_gps_longitude_longitude_decode(double value)
{
    return ((float)value);
}

bool can_gps_longitude_longitude_is_in_range(double value)
{
    (void)value;

    return (true);
}

int can_gps_date_pack(
    uint8_t *dst_p,
    const struct can_gps_date_t *src_p,
    size_t size)
{
    if (size < 6u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u8(src_p->year, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->month, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->day, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->hour, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->minute, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->second, 0u, 0xffu);

    return (6);
}

int can_gps_date_unpack(
    struct can_gps_date_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u)
    {
        return (-EINVAL);
    }

    dst_p->year = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->month = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->day = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->hour = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->minute = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->second = unpack_right_shift_u8(src_p[5], 0u, 0xffu);

    return (0);
}

uint8_t can_gps_date_year_encode(float value)
{
    return (uint8_t)(value);
}

float can_gps_date_year_decode(uint8_t value)
{
    return ((float)value);
}

bool can_gps_date_year_is_in_range(uint8_t value)
{
    return (value <= 99u);
}

uint8_t can_gps_date_month_encode(float value)
{
    return (uint8_t)(value);
}

float can_gps_date_month_decode(uint8_t value)
{
    return ((float)value);
}

bool can_gps_date_month_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 12u));
}

uint8_t can_gps_date_day_encode(float value)
{
    return (uint8_t)(value);
}

float can_gps_date_day_decode(uint8_t value)
{
    return ((float)value);
}

bool can_gps_date_day_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 31u));
}

uint8_t can_gps_date_hour_encode(float value)
{
    return (uint8_t)(value);
}

float can_gps_date_hour_decode(uint8_t value)
{
    return ((float)value);
}

bool can_gps_date_hour_is_in_range(uint8_t value)
{
    return (value <= 23u);
}

uint8_t can_gps_date_minute_encode(float value)
{
    return (uint8_t)(value);
}

float can_gps_date_minute_decode(uint8_t value)
{
    return ((float)value);
}

bool can_gps_date_minute_is_in_range(uint8_t value)
{
    return (value <= 59u);
}

uint8_t can_gps_date_second_encode(float value)
{
    return (uint8_t)(value);
}

float can_gps_date_second_decode(uint8_t value)
{
    return ((float)value);
}

bool can_gps_date_second_is_in_range(uint8_t value)
{
    return (value <= 59u);
}

int can_imu_status_pack(
    uint8_t *dst_p,
    const struct can_imu_status_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->status, 0u, 0xffu);

    return (1);
}

int can_imu_status_unpack(
    struct can_imu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->status = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t can_imu_status_status_encode(float value)
{
    return (uint8_t)(value);
}

float can_imu_status_status_decode(uint8_t value)
{
    return ((float)value);
}

bool can_imu_status_status_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

int can_imu_orientation_pack(
    uint8_t *dst_p,
    const struct can_imu_orientation_t *src_p,
    size_t size)
{
    uint16_t w;
    uint16_t x;
    uint16_t y;
    uint16_t z;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    w = (uint16_t)src_p->w;
    dst_p[0] |= pack_left_shift_u16(w, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(w, 8u, 0xffu);
    x = (uint16_t)src_p->x;
    dst_p[2] |= pack_left_shift_u16(x, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(x, 8u, 0xffu);
    y = (uint16_t)src_p->y;
    dst_p[4] |= pack_left_shift_u16(y, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(y, 8u, 0xffu);
    z = (uint16_t)src_p->z;
    dst_p[6] |= pack_left_shift_u16(z, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(z, 8u, 0xffu);

    return (8);
}

int can_imu_orientation_unpack(
    struct can_imu_orientation_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t w;
    uint16_t x;
    uint16_t y;
    uint16_t z;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    w = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    w |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->w = (int16_t)w;
    x = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    x |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->x = (int16_t)x;
    y = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    y |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->y = (int16_t)y;
    z = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    z |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->z = (int16_t)z;

    return (0);
}

int16_t can_imu_orientation_w_encode(float value)
{
    return (int16_t)(value / 0.00006103515625f);
}

float can_imu_orientation_w_decode(int16_t value)
{
    return ((float)value * 0.00006103515625f);
}

bool can_imu_orientation_w_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_imu_orientation_x_encode(float value)
{
    return (int16_t)(value / 0.00006103515625f);
}

float can_imu_orientation_x_decode(int16_t value)
{
    return ((float)value * 0.00006103515625f);
}

bool can_imu_orientation_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_imu_orientation_y_encode(float value)
{
    return (int16_t)(value / 0.00006103515625f);
}

float can_imu_orientation_y_decode(int16_t value)
{
    return ((float)value * 0.00006103515625f);
}

bool can_imu_orientation_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_imu_orientation_z_encode(float value)
{
    return (int16_t)(value / 0.00006103515625f);
}

float can_imu_orientation_z_decode(int16_t value)
{
    return ((float)value * 0.00006103515625f);
}

bool can_imu_orientation_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_imu_linear_acceleration_pack(
    uint8_t *dst_p,
    const struct can_imu_linear_acceleration_t *src_p,
    size_t size)
{
    uint16_t x;
    uint16_t y;
    uint16_t z;

    if (size < 6u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    x = (uint16_t)src_p->x;
    dst_p[0] |= pack_left_shift_u16(x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(x, 8u, 0xffu);
    y = (uint16_t)src_p->y;
    dst_p[2] |= pack_left_shift_u16(y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(y, 8u, 0xffu);
    z = (uint16_t)src_p->z;
    dst_p[4] |= pack_left_shift_u16(z, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(z, 8u, 0xffu);

    return (6);
}

int can_imu_linear_acceleration_unpack(
    struct can_imu_linear_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t x;
    uint16_t y;
    uint16_t z;

    if (size < 6u)
    {
        return (-EINVAL);
    }

    x = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->x = (int16_t)x;
    y = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->y = (int16_t)y;
    z = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    z |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->z = (int16_t)z;

    return (0);
}

int16_t can_imu_linear_acceleration_x_encode(float value)
{
    return (int16_t)(value / 0.01f);
}

float can_imu_linear_acceleration_x_decode(int16_t value)
{
    return ((float)value * 0.01f);
}

bool can_imu_linear_acceleration_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_imu_linear_acceleration_y_encode(float value)
{
    return (int16_t)(value / 0.01f);
}

float can_imu_linear_acceleration_y_decode(int16_t value)
{
    return ((float)value * 0.01f);
}

bool can_imu_linear_acceleration_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_imu_linear_acceleration_z_encode(float value)
{
    return (int16_t)(value / 0.01f);
}

float can_imu_linear_acceleration_z_decode(int16_t value)
{
    return ((float)value * 0.01f);
}

bool can_imu_linear_acceleration_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_imu_magnetic_field_pack(
    uint8_t *dst_p,
    const struct can_imu_magnetic_field_t *src_p,
    size_t size)
{
    uint16_t x;
    uint16_t y;
    uint16_t z;

    if (size < 6u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    x = (uint16_t)src_p->x;
    dst_p[0] |= pack_left_shift_u16(x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(x, 8u, 0xffu);
    y = (uint16_t)src_p->y;
    dst_p[2] |= pack_left_shift_u16(y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(y, 8u, 0xffu);
    z = (uint16_t)src_p->z;
    dst_p[4] |= pack_left_shift_u16(z, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(z, 8u, 0xffu);

    return (6);
}

int can_imu_magnetic_field_unpack(
    struct can_imu_magnetic_field_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t x;
    uint16_t y;
    uint16_t z;

    if (size < 6u)
    {
        return (-EINVAL);
    }

    x = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->x = (int16_t)x;
    y = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->y = (int16_t)y;
    z = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    z |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->z = (int16_t)z;

    return (0);
}

int16_t can_imu_magnetic_field_x_encode(float value)
{
    return (int16_t)(value / 0.0625f);
}

float can_imu_magnetic_field_x_decode(int16_t value)
{
    return ((float)value * 0.0625f);
}

bool can_imu_magnetic_field_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_imu_magnetic_field_y_encode(float value)
{
    return (int16_t)(value / 0.0625f);
}

float can_imu_magnetic_field_y_decode(int16_t value)
{
    return ((float)value * 0.0625f);
}

bool can_imu_magnetic_field_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_imu_magnetic_field_z_encode(float value)
{
    return (int16_t)(value / 0.0625f);
}

float can_imu_magnetic_field_z_decode(int16_t value)
{
    return ((float)value * 0.0625f);
}

bool can_imu_magnetic_field_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_imu_gyration_pack(
    uint8_t *dst_p,
    const struct can_imu_gyration_t *src_p,
    size_t size)
{
    uint16_t x;
    uint16_t y;
    uint16_t z;

    if (size < 6u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    x = (uint16_t)src_p->x;
    dst_p[0] |= pack_left_shift_u16(x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(x, 8u, 0xffu);
    y = (uint16_t)src_p->y;
    dst_p[2] |= pack_left_shift_u16(y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(y, 8u, 0xffu);
    z = (uint16_t)src_p->z;
    dst_p[4] |= pack_left_shift_u16(z, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(z, 8u, 0xffu);

    return (6);
}

int can_imu_gyration_unpack(
    struct can_imu_gyration_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t x;
    uint16_t y;
    uint16_t z;

    if (size < 6u)
    {
        return (-EINVAL);
    }

    x = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->x = (int16_t)x;
    y = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->y = (int16_t)y;
    z = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    z |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->z = (int16_t)z;

    return (0);
}

int16_t can_imu_gyration_x_encode(float value)
{
    return (int16_t)(value / 0.0011111111111111111f);
}

float can_imu_gyration_x_decode(int16_t value)
{
    return ((float)value * 0.0011111111111111111f);
}

bool can_imu_gyration_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_imu_gyration_y_encode(float value)
{
    return (int16_t)(value / 0.0011111111111111111f);
}

float can_imu_gyration_y_decode(int16_t value)
{
    return ((float)value * 0.0011111111111111111f);
}

bool can_imu_gyration_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_imu_gyration_z_encode(float value)
{
    return (int16_t)(value / 0.0011111111111111111f);
}

float can_imu_gyration_z_decode(int16_t value)
{
    return ((float)value * 0.0011111111111111111f);
}

bool can_imu_gyration_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_metal_detector_status_pack(
    uint8_t *dst_p,
    const struct can_metal_detector_status_t *src_p,
    size_t size)
{
    if (size < 2u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u8(src_p->channel_1, 0u, 0x03u);
    dst_p[0] |= pack_left_shift_u8(src_p->channel_2, 2u, 0x0cu);
    dst_p[0] |= pack_left_shift_u8(src_p->channel_3, 4u, 0x30u);
    dst_p[0] |= pack_left_shift_u8(src_p->channel_4, 6u, 0xc0u);
    dst_p[1] |= pack_left_shift_u8(src_p->channel_5, 0u, 0x03u);
    dst_p[1] |= pack_left_shift_u8(src_p->channel_6, 2u, 0x0cu);
    dst_p[1] |= pack_left_shift_u8(src_p->channel_7, 4u, 0x30u);
    dst_p[1] |= pack_left_shift_u8(src_p->channel_8, 6u, 0xc0u);

    return (2);
}

int can_metal_detector_status_unpack(
    struct can_metal_detector_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u)
    {
        return (-EINVAL);
    }

    dst_p->channel_1 = unpack_right_shift_u8(src_p[0], 0u, 0x03u);
    dst_p->channel_2 = unpack_right_shift_u8(src_p[0], 2u, 0x0cu);
    dst_p->channel_3 = unpack_right_shift_u8(src_p[0], 4u, 0x30u);
    dst_p->channel_4 = unpack_right_shift_u8(src_p[0], 6u, 0xc0u);
    dst_p->channel_5 = unpack_right_shift_u8(src_p[1], 0u, 0x03u);
    dst_p->channel_6 = unpack_right_shift_u8(src_p[1], 2u, 0x0cu);
    dst_p->channel_7 = unpack_right_shift_u8(src_p[1], 4u, 0x30u);
    dst_p->channel_8 = unpack_right_shift_u8(src_p[1], 6u, 0xc0u);

    return (0);
}

uint8_t can_metal_detector_status_channel_1_encode(float value)
{
    return (uint8_t)(value);
}

float can_metal_detector_status_channel_1_decode(uint8_t value)
{
    return ((float)value);
}

bool can_metal_detector_status_channel_1_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

uint8_t can_metal_detector_status_channel_2_encode(float value)
{
    return (uint8_t)(value);
}

float can_metal_detector_status_channel_2_decode(uint8_t value)
{
    return ((float)value);
}

bool can_metal_detector_status_channel_2_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

uint8_t can_metal_detector_status_channel_3_encode(float value)
{
    return (uint8_t)(value);
}

float can_metal_detector_status_channel_3_decode(uint8_t value)
{
    return ((float)value);
}

bool can_metal_detector_status_channel_3_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

uint8_t can_metal_detector_status_channel_4_encode(float value)
{
    return (uint8_t)(value);
}

float can_metal_detector_status_channel_4_decode(uint8_t value)
{
    return ((float)value);
}

bool can_metal_detector_status_channel_4_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

uint8_t can_metal_detector_status_channel_5_encode(float value)
{
    return (uint8_t)(value);
}

float can_metal_detector_status_channel_5_decode(uint8_t value)
{
    return ((float)value);
}

bool can_metal_detector_status_channel_5_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

uint8_t can_metal_detector_status_channel_6_encode(float value)
{
    return (uint8_t)(value);
}

float can_metal_detector_status_channel_6_decode(uint8_t value)
{
    return ((float)value);
}

bool can_metal_detector_status_channel_6_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

uint8_t can_metal_detector_status_channel_7_encode(float value)
{
    return (uint8_t)(value);
}

float can_metal_detector_status_channel_7_decode(uint8_t value)
{
    return ((float)value);
}

bool can_metal_detector_status_channel_7_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

uint8_t can_metal_detector_status_channel_8_encode(float value)
{
    return (uint8_t)(value);
}

float can_metal_detector_status_channel_8_decode(uint8_t value)
{
    return ((float)value);
}

bool can_metal_detector_status_channel_8_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

int can_metal_detector_value_1234_pack(
    uint8_t *dst_p,
    const struct can_metal_detector_value_1234_t *src_p,
    size_t size)
{
    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->channel_1, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->channel_1, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->channel_2, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->channel_2, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->channel_3, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->channel_3, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->channel_4, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->channel_4, 8u, 0xffu);

    return (8);
}

int can_metal_detector_value_1234_unpack(
    struct can_metal_detector_value_1234_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u)
    {
        return (-EINVAL);
    }

    dst_p->channel_1 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->channel_1 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->channel_2 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->channel_2 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->channel_3 = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->channel_3 |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->channel_4 = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->channel_4 |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_metal_detector_value_1234_channel_1_encode(float value)
{
    return (uint16_t)(value);
}

float can_metal_detector_value_1234_channel_1_decode(uint16_t value)
{
    return ((float)value);
}

bool can_metal_detector_value_1234_channel_1_is_in_range(uint16_t value)
{
    return (value <= 4095u);
}

uint16_t can_metal_detector_value_1234_channel_2_encode(float value)
{
    return (uint16_t)(value);
}

float can_metal_detector_value_1234_channel_2_decode(uint16_t value)
{
    return ((float)value);
}

bool can_metal_detector_value_1234_channel_2_is_in_range(uint16_t value)
{
    return (value <= 4095u);
}

uint16_t can_metal_detector_value_1234_channel_3_encode(float value)
{
    return (uint16_t)(value);
}

float can_metal_detector_value_1234_channel_3_decode(uint16_t value)
{
    return ((float)value);
}

bool can_metal_detector_value_1234_channel_3_is_in_range(uint16_t value)
{
    return (value <= 4095u);
}

uint16_t can_metal_detector_value_1234_channel_4_encode(float value)
{
    return (uint16_t)(value);
}

float can_metal_detector_value_1234_channel_4_decode(uint16_t value)
{
    return ((float)value);
}

bool can_metal_detector_value_1234_channel_4_is_in_range(uint16_t value)
{
    return (value <= 4095u);
}

int can_metal_detector_value_5678_pack(
    uint8_t *dst_p,
    const struct can_metal_detector_value_5678_t *src_p,
    size_t size)
{
    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->channel_5, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->channel_5, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->channel_6, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->channel_6, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->channel_7, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->channel_7, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->channel_8, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->channel_8, 8u, 0xffu);

    return (8);
}

int can_metal_detector_value_5678_unpack(
    struct can_metal_detector_value_5678_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u)
    {
        return (-EINVAL);
    }

    dst_p->channel_5 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->channel_5 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->channel_6 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->channel_6 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->channel_7 = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->channel_7 |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->channel_8 = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->channel_8 |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_metal_detector_value_5678_channel_5_encode(float value)
{
    return (uint16_t)(value);
}

float can_metal_detector_value_5678_channel_5_decode(uint16_t value)
{
    return ((float)value);
}

bool can_metal_detector_value_5678_channel_5_is_in_range(uint16_t value)
{
    return (value <= 4095u);
}

uint16_t can_metal_detector_value_5678_channel_6_encode(float value)
{
    return (uint16_t)(value);
}

float can_metal_detector_value_5678_channel_6_decode(uint16_t value)
{
    return ((float)value);
}

bool can_metal_detector_value_5678_channel_6_is_in_range(uint16_t value)
{
    return (value <= 4095u);
}

uint16_t can_metal_detector_value_5678_channel_7_encode(float value)
{
    return (uint16_t)(value);
}

float can_metal_detector_value_5678_channel_7_decode(uint16_t value)
{
    return ((float)value);
}

bool can_metal_detector_value_5678_channel_7_is_in_range(uint16_t value)
{
    return (value <= 4095u);
}

uint16_t can_metal_detector_value_5678_channel_8_encode(float value)
{
    return (uint16_t)(value);
}

float can_metal_detector_value_5678_channel_8_decode(uint16_t value)
{
    return ((float)value);
}

bool can_metal_detector_value_5678_channel_8_is_in_range(uint16_t value)
{
    return (value <= 4095u);
}

int can_metal_detector_estimated_position_pack(
    uint8_t *dst_p,
    const struct can_metal_detector_estimated_position_t *src_p,
    size_t size)
{
    uint16_t x;
    uint16_t y;
    uint16_t z;

    if (size < 6u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    x = (uint16_t)src_p->x;
    dst_p[0] |= pack_left_shift_u16(x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(x, 8u, 0xffu);
    y = (uint16_t)src_p->y;
    dst_p[2] |= pack_left_shift_u16(y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(y, 8u, 0xffu);
    z = (uint16_t)src_p->z;
    dst_p[4] |= pack_left_shift_u16(z, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(z, 8u, 0xffu);

    return (6);
}

int can_metal_detector_estimated_position_unpack(
    struct can_metal_detector_estimated_position_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t x;
    uint16_t y;
    uint16_t z;

    if (size < 6u)
    {
        return (-EINVAL);
    }

    x = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->x = (int16_t)x;
    y = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->y = (int16_t)y;
    z = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    z |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->z = (int16_t)z;

    return (0);
}

int16_t can_metal_detector_estimated_position_x_encode(float value)
{
    return (int16_t)(value / 0.001f);
}

float can_metal_detector_estimated_position_x_decode(int16_t value)
{
    return ((float)value * 0.001f);
}

bool can_metal_detector_estimated_position_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_metal_detector_estimated_position_y_encode(float value)
{
    return (int16_t)(value / 0.001f);
}

float can_metal_detector_estimated_position_y_decode(int16_t value)
{
    return ((float)value * 0.001f);
}

bool can_metal_detector_estimated_position_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_metal_detector_estimated_position_z_encode(float value)
{
    return (int16_t)(value / 0.001f);
}

float can_metal_detector_estimated_position_z_decode(int16_t value)
{
    return ((float)value * 0.001f);
}

bool can_metal_detector_estimated_position_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_odrive_left_heartbeat_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_heartbeat_t *src_p,
    size_t size)
{
    if (size < 6u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u32(src_p->axis_error, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->axis_error, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->axis_error, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->axis_error, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->axis_state, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->controller_status, 0u, 0xffu);

    return (6);
}

int can_odrive_left_heartbeat_unpack(
    struct can_odrive_left_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u)
    {
        return (-EINVAL);
    }

    dst_p->axis_error = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->axis_error |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->axis_error |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->axis_error |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->axis_state = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->controller_status = unpack_right_shift_u8(src_p[5], 0u, 0xffu);

    return (0);
}

uint32_t can_odrive_left_heartbeat_axis_error_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_left_heartbeat_axis_error_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_left_heartbeat_axis_error_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint8_t can_odrive_left_heartbeat_axis_state_encode(float value)
{
    return (uint8_t)(value);
}

float can_odrive_left_heartbeat_axis_state_decode(uint8_t value)
{
    return ((float)value);
}

bool can_odrive_left_heartbeat_axis_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_odrive_left_heartbeat_controller_status_encode(float value)
{
    return (uint8_t)(value);
}

float can_odrive_left_heartbeat_controller_status_decode(uint8_t value)
{
    return ((float)value);
}

bool can_odrive_left_heartbeat_controller_status_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_odrive_left_estop_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_estop_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_odrive_left_estop_unpack(
    struct can_odrive_left_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_odrive_left_get_motor_error_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_get_motor_error_t *src_p,
    size_t size)
{
    if (size < 4u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->motor_error, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->motor_error, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->motor_error, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->motor_error, 24u, 0xffu);

    return (4);
}

int can_odrive_left_get_motor_error_unpack(
    struct can_odrive_left_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u)
    {
        return (-EINVAL);
    }

    dst_p->motor_error = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->motor_error |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->motor_error |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->motor_error |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

uint32_t can_odrive_left_get_motor_error_motor_error_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_left_get_motor_error_motor_error_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_left_get_motor_error_motor_error_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_odrive_left_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_get_encoder_error_t *src_p,
    size_t size)
{
    if (size < 4u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->encoder_error, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->encoder_error, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->encoder_error, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->encoder_error, 24u, 0xffu);

    return (4);
}

int can_odrive_left_get_encoder_error_unpack(
    struct can_odrive_left_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u)
    {
        return (-EINVAL);
    }

    dst_p->encoder_error = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->encoder_error |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->encoder_error |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->encoder_error |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

uint32_t can_odrive_left_get_encoder_error_encoder_error_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_left_get_encoder_error_encoder_error_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_left_get_encoder_error_encoder_error_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_odrive_left_set_axis_state_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_set_axis_state_t *src_p,
    size_t size)
{
    if (size < 4u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->axis_requested_state, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->axis_requested_state, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->axis_requested_state, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->axis_requested_state, 24u, 0xffu);

    return (4);
}

int can_odrive_left_set_axis_state_unpack(
    struct can_odrive_left_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u)
    {
        return (-EINVAL);
    }

    dst_p->axis_requested_state = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->axis_requested_state |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->axis_requested_state |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->axis_requested_state |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

uint32_t can_odrive_left_set_axis_state_axis_requested_state_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_left_set_axis_state_axis_requested_state_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_left_set_axis_state_axis_requested_state_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_odrive_left_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_get_encoder_estimates_t *src_p,
    size_t size)
{
    uint32_t pos_estimate;
    uint32_t vel_estimate;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&pos_estimate, &src_p->pos_estimate, sizeof(pos_estimate));
    dst_p[0] |= pack_left_shift_u32(pos_estimate, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(pos_estimate, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(pos_estimate, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(pos_estimate, 24u, 0xffu);
    memcpy(&vel_estimate, &src_p->vel_estimate, sizeof(vel_estimate));
    dst_p[4] |= pack_left_shift_u32(vel_estimate, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(vel_estimate, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(vel_estimate, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(vel_estimate, 24u, 0xffu);

    return (8);
}

int can_odrive_left_get_encoder_estimates_unpack(
    struct can_odrive_left_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t pos_estimate;
    uint32_t vel_estimate;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    pos_estimate = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    pos_estimate |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    pos_estimate |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    pos_estimate |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->pos_estimate, &pos_estimate, sizeof(dst_p->pos_estimate));
    vel_estimate = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    vel_estimate |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    vel_estimate |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    vel_estimate |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->vel_estimate, &vel_estimate, sizeof(dst_p->vel_estimate));

    return (0);
}

float can_odrive_left_get_encoder_estimates_pos_estimate_encode(float value)
{
    return (float)(value / 6.283185307179586f);
}

float can_odrive_left_get_encoder_estimates_pos_estimate_decode(float value)
{
    return ((float)value * 6.283185307179586f);
}

bool can_odrive_left_get_encoder_estimates_pos_estimate_is_in_range(float value)
{
    (void)value;

    return (true);
}

float can_odrive_left_get_encoder_estimates_vel_estimate_encode(float value)
{
    return (float)(value / 6.283185307179586f);
}

float can_odrive_left_get_encoder_estimates_vel_estimate_decode(float value)
{
    return ((float)value * 6.283185307179586f);
}

bool can_odrive_left_get_encoder_estimates_vel_estimate_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_odrive_left_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_get_encoder_count_t *src_p,
    size_t size)
{
    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->shadow_count, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->shadow_count, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->shadow_count, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->shadow_count, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->count_in_cpr, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->count_in_cpr, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->count_in_cpr, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->count_in_cpr, 24u, 0xffu);

    return (8);
}

int can_odrive_left_get_encoder_count_unpack(
    struct can_odrive_left_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u)
    {
        return (-EINVAL);
    }

    dst_p->shadow_count = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->shadow_count |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->shadow_count |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->shadow_count |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->count_in_cpr = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->count_in_cpr |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->count_in_cpr |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->count_in_cpr |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

uint32_t can_odrive_left_get_encoder_count_shadow_count_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_left_get_encoder_count_shadow_count_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_left_get_encoder_count_shadow_count_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t can_odrive_left_get_encoder_count_count_in_cpr_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_left_get_encoder_count_count_in_cpr_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_left_get_encoder_count_count_in_cpr_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_odrive_left_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_set_controller_mode_t *src_p,
    size_t size)
{
    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->control_mode, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->control_mode, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->control_mode, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->control_mode, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->input_mode, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->input_mode, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->input_mode, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->input_mode, 24u, 0xffu);

    return (8);
}

int can_odrive_left_set_controller_mode_unpack(
    struct can_odrive_left_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u)
    {
        return (-EINVAL);
    }

    dst_p->control_mode = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->control_mode |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->control_mode |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->control_mode |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->input_mode = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->input_mode |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->input_mode |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->input_mode |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

uint32_t can_odrive_left_set_controller_mode_control_mode_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_left_set_controller_mode_control_mode_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_left_set_controller_mode_control_mode_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t can_odrive_left_set_controller_mode_input_mode_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_left_set_controller_mode_input_mode_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_left_set_controller_mode_input_mode_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_odrive_left_set_input_pos_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_set_input_pos_t *src_p,
    size_t size)
{
    uint16_t torque_ff;
    uint16_t vel_ff;
    uint32_t input_pos;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&input_pos, &src_p->input_pos, sizeof(input_pos));
    dst_p[0] |= pack_left_shift_u32(input_pos, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(input_pos, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(input_pos, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(input_pos, 24u, 0xffu);
    vel_ff = (uint16_t)src_p->vel_ff;
    dst_p[4] |= pack_left_shift_u16(vel_ff, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(vel_ff, 8u, 0xffu);
    torque_ff = (uint16_t)src_p->torque_ff;
    dst_p[6] |= pack_left_shift_u16(torque_ff, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(torque_ff, 8u, 0xffu);

    return (8);
}

int can_odrive_left_set_input_pos_unpack(
    struct can_odrive_left_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t torque_ff;
    uint16_t vel_ff;
    uint32_t input_pos;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    input_pos = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    input_pos |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    input_pos |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    input_pos |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->input_pos, &input_pos, sizeof(dst_p->input_pos));
    vel_ff = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    vel_ff |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->vel_ff = (int16_t)vel_ff;
    torque_ff = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    torque_ff |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->torque_ff = (int16_t)torque_ff;

    return (0);
}

float can_odrive_left_set_input_pos_input_pos_encode(float value)
{
    return (float)(value);
}

float can_odrive_left_set_input_pos_input_pos_decode(float value)
{
    return ((float)value);
}

bool can_odrive_left_set_input_pos_input_pos_is_in_range(float value)
{
    (void)value;

    return (true);
}

int16_t can_odrive_left_set_input_pos_vel_ff_encode(float value)
{
    return (int16_t)(value / 0.001f);
}

float can_odrive_left_set_input_pos_vel_ff_decode(int16_t value)
{
    return ((float)value * 0.001f);
}

bool can_odrive_left_set_input_pos_vel_ff_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_odrive_left_set_input_pos_torque_ff_encode(float value)
{
    return (int16_t)(value / 0.001f);
}

float can_odrive_left_set_input_pos_torque_ff_decode(int16_t value)
{
    return ((float)value * 0.001f);
}

bool can_odrive_left_set_input_pos_torque_ff_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_odrive_left_set_input_vel_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_set_input_vel_t *src_p,
    size_t size)
{
    uint32_t input_vel;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&input_vel, &src_p->input_vel, sizeof(input_vel));
    dst_p[0] |= pack_left_shift_u32(input_vel, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(input_vel, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(input_vel, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(input_vel, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->input_torque_ff, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->input_torque_ff, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->input_torque_ff, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->input_torque_ff, 24u, 0xffu);

    return (8);
}

int can_odrive_left_set_input_vel_unpack(
    struct can_odrive_left_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t input_vel;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    input_vel = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    input_vel |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    input_vel |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    input_vel |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->input_vel, &input_vel, sizeof(dst_p->input_vel));
    dst_p->input_torque_ff = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->input_torque_ff |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->input_torque_ff |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->input_torque_ff |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

float can_odrive_left_set_input_vel_input_vel_encode(float value)
{
    return (float)(value / 6.283185307179586f);
}

float can_odrive_left_set_input_vel_input_vel_decode(float value)
{
    return ((float)value * 6.283185307179586f);
}

bool can_odrive_left_set_input_vel_input_vel_is_in_range(float value)
{
    (void)value;

    return (true);
}

uint32_t can_odrive_left_set_input_vel_input_torque_ff_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_left_set_input_vel_input_torque_ff_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_left_set_input_vel_input_torque_ff_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_odrive_left_set_input_torque_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_set_input_torque_t *src_p,
    size_t size)
{
    uint32_t imput_torque;

    if (size < 4u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&imput_torque, &src_p->imput_torque, sizeof(imput_torque));
    dst_p[0] |= pack_left_shift_u32(imput_torque, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(imput_torque, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(imput_torque, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(imput_torque, 24u, 0xffu);

    return (4);
}

int can_odrive_left_set_input_torque_unpack(
    struct can_odrive_left_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t imput_torque;

    if (size < 4u)
    {
        return (-EINVAL);
    }

    imput_torque = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    imput_torque |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    imput_torque |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    imput_torque |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->imput_torque, &imput_torque, sizeof(dst_p->imput_torque));

    return (0);
}

float can_odrive_left_set_input_torque_imput_torque_encode(float value)
{
    return (float)(value);
}

float can_odrive_left_set_input_torque_imput_torque_decode(float value)
{
    return ((float)value);
}

bool can_odrive_left_set_input_torque_imput_torque_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_odrive_left_set_limits_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_set_limits_t *src_p,
    size_t size)
{
    uint32_t current_limit;
    uint32_t velocity_limit;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&velocity_limit, &src_p->velocity_limit, sizeof(velocity_limit));
    dst_p[0] |= pack_left_shift_u32(velocity_limit, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(velocity_limit, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(velocity_limit, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(velocity_limit, 24u, 0xffu);
    memcpy(&current_limit, &src_p->current_limit, sizeof(current_limit));
    dst_p[4] |= pack_left_shift_u32(current_limit, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(current_limit, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(current_limit, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(current_limit, 24u, 0xffu);

    return (8);
}

int can_odrive_left_set_limits_unpack(
    struct can_odrive_left_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t current_limit;
    uint32_t velocity_limit;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    velocity_limit = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    velocity_limit |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    velocity_limit |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    velocity_limit |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->velocity_limit, &velocity_limit, sizeof(dst_p->velocity_limit));
    current_limit = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    current_limit |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    current_limit |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    current_limit |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->current_limit, &current_limit, sizeof(dst_p->current_limit));

    return (0);
}

float can_odrive_left_set_limits_velocity_limit_encode(float value)
{
    return (float)(value);
}

float can_odrive_left_set_limits_velocity_limit_decode(float value)
{
    return ((float)value);
}

bool can_odrive_left_set_limits_velocity_limit_is_in_range(float value)
{
    (void)value;

    return (true);
}

float can_odrive_left_set_limits_current_limit_encode(float value)
{
    return (float)(value);
}

float can_odrive_left_set_limits_current_limit_decode(float value)
{
    return ((float)value);
}

bool can_odrive_left_set_limits_current_limit_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_odrive_left_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_get_vbus_voltage_t *src_p,
    size_t size)
{
    uint32_t vbus_voltage;

    if (size < 4u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&vbus_voltage, &src_p->vbus_voltage, sizeof(vbus_voltage));
    dst_p[0] |= pack_left_shift_u32(vbus_voltage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(vbus_voltage, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(vbus_voltage, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(vbus_voltage, 24u, 0xffu);

    return (4);
}

int can_odrive_left_get_vbus_voltage_unpack(
    struct can_odrive_left_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t vbus_voltage;

    if (size < 4u)
    {
        return (-EINVAL);
    }

    vbus_voltage = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    vbus_voltage |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    vbus_voltage |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    vbus_voltage |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->vbus_voltage, &vbus_voltage, sizeof(dst_p->vbus_voltage));

    return (0);
}

float can_odrive_left_get_vbus_voltage_vbus_voltage_encode(float value)
{
    return (float)(value);
}

float can_odrive_left_get_vbus_voltage_vbus_voltage_decode(float value)
{
    return ((float)value);
}

bool can_odrive_left_get_vbus_voltage_vbus_voltage_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_odrive_left_clear_errors_pack(
    uint8_t *dst_p,
    const struct can_odrive_left_clear_errors_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_odrive_left_clear_errors_unpack(
    struct can_odrive_left_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_odrive_right_heartbeat_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_heartbeat_t *src_p,
    size_t size)
{
    if (size < 6u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u32(src_p->axis_error, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->axis_error, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->axis_error, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->axis_error, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->axis_state, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->controller_status, 0u, 0xffu);

    return (6);
}

int can_odrive_right_heartbeat_unpack(
    struct can_odrive_right_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u)
    {
        return (-EINVAL);
    }

    dst_p->axis_error = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->axis_error |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->axis_error |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->axis_error |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->axis_state = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->controller_status = unpack_right_shift_u8(src_p[5], 0u, 0xffu);

    return (0);
}

uint32_t can_odrive_right_heartbeat_axis_error_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_right_heartbeat_axis_error_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_right_heartbeat_axis_error_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint8_t can_odrive_right_heartbeat_axis_state_encode(float value)
{
    return (uint8_t)(value);
}

float can_odrive_right_heartbeat_axis_state_decode(uint8_t value)
{
    return ((float)value);
}

bool can_odrive_right_heartbeat_axis_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_odrive_right_heartbeat_controller_status_encode(float value)
{
    return (uint8_t)(value);
}

float can_odrive_right_heartbeat_controller_status_decode(uint8_t value)
{
    return ((float)value);
}

bool can_odrive_right_heartbeat_controller_status_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_odrive_right_estop_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_estop_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_odrive_right_estop_unpack(
    struct can_odrive_right_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_odrive_right_get_motor_error_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_get_motor_error_t *src_p,
    size_t size)
{
    if (size < 4u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->motor_error, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->motor_error, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->motor_error, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->motor_error, 24u, 0xffu);

    return (4);
}

int can_odrive_right_get_motor_error_unpack(
    struct can_odrive_right_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u)
    {
        return (-EINVAL);
    }

    dst_p->motor_error = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->motor_error |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->motor_error |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->motor_error |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

uint32_t can_odrive_right_get_motor_error_motor_error_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_right_get_motor_error_motor_error_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_right_get_motor_error_motor_error_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_odrive_right_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_get_encoder_error_t *src_p,
    size_t size)
{
    if (size < 4u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->encoder_error, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->encoder_error, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->encoder_error, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->encoder_error, 24u, 0xffu);

    return (4);
}

int can_odrive_right_get_encoder_error_unpack(
    struct can_odrive_right_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u)
    {
        return (-EINVAL);
    }

    dst_p->encoder_error = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->encoder_error |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->encoder_error |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->encoder_error |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

uint32_t can_odrive_right_get_encoder_error_encoder_error_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_right_get_encoder_error_encoder_error_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_right_get_encoder_error_encoder_error_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_odrive_right_set_axis_state_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_set_axis_state_t *src_p,
    size_t size)
{
    if (size < 4u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->axis_requested_state, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->axis_requested_state, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->axis_requested_state, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->axis_requested_state, 24u, 0xffu);

    return (4);
}

int can_odrive_right_set_axis_state_unpack(
    struct can_odrive_right_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u)
    {
        return (-EINVAL);
    }

    dst_p->axis_requested_state = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->axis_requested_state |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->axis_requested_state |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->axis_requested_state |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

uint32_t can_odrive_right_set_axis_state_axis_requested_state_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_right_set_axis_state_axis_requested_state_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_right_set_axis_state_axis_requested_state_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_odrive_right_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_get_encoder_estimates_t *src_p,
    size_t size)
{
    uint32_t pos_estimate;
    uint32_t vel_estimate;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&pos_estimate, &src_p->pos_estimate, sizeof(pos_estimate));
    dst_p[0] |= pack_left_shift_u32(pos_estimate, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(pos_estimate, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(pos_estimate, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(pos_estimate, 24u, 0xffu);
    memcpy(&vel_estimate, &src_p->vel_estimate, sizeof(vel_estimate));
    dst_p[4] |= pack_left_shift_u32(vel_estimate, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(vel_estimate, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(vel_estimate, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(vel_estimate, 24u, 0xffu);

    return (8);
}

int can_odrive_right_get_encoder_estimates_unpack(
    struct can_odrive_right_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t pos_estimate;
    uint32_t vel_estimate;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    pos_estimate = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    pos_estimate |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    pos_estimate |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    pos_estimate |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->pos_estimate, &pos_estimate, sizeof(dst_p->pos_estimate));
    vel_estimate = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    vel_estimate |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    vel_estimate |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    vel_estimate |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->vel_estimate, &vel_estimate, sizeof(dst_p->vel_estimate));

    return (0);
}

float can_odrive_right_get_encoder_estimates_pos_estimate_encode(float value)
{
    return (float)(value / 6.283185307179586f);
}

float can_odrive_right_get_encoder_estimates_pos_estimate_decode(float value)
{
    return ((float)value * 6.283185307179586f);
}

bool can_odrive_right_get_encoder_estimates_pos_estimate_is_in_range(float value)
{
    (void)value;

    return (true);
}

float can_odrive_right_get_encoder_estimates_vel_estimate_encode(float value)
{
    return (float)(value / 6.283185307179586f);
}

float can_odrive_right_get_encoder_estimates_vel_estimate_decode(float value)
{
    return ((float)value * 6.283185307179586f);
}

bool can_odrive_right_get_encoder_estimates_vel_estimate_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_odrive_right_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_get_encoder_count_t *src_p,
    size_t size)
{
    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->shadow_count, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->shadow_count, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->shadow_count, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->shadow_count, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->count_in_cpr, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->count_in_cpr, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->count_in_cpr, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->count_in_cpr, 24u, 0xffu);

    return (8);
}

int can_odrive_right_get_encoder_count_unpack(
    struct can_odrive_right_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u)
    {
        return (-EINVAL);
    }

    dst_p->shadow_count = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->shadow_count |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->shadow_count |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->shadow_count |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->count_in_cpr = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->count_in_cpr |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->count_in_cpr |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->count_in_cpr |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

uint32_t can_odrive_right_get_encoder_count_shadow_count_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_right_get_encoder_count_shadow_count_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_right_get_encoder_count_shadow_count_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t can_odrive_right_get_encoder_count_count_in_cpr_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_right_get_encoder_count_count_in_cpr_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_right_get_encoder_count_count_in_cpr_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_odrive_right_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_set_controller_mode_t *src_p,
    size_t size)
{
    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->control_mode, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->control_mode, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->control_mode, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->control_mode, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->input_mode, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->input_mode, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->input_mode, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->input_mode, 24u, 0xffu);

    return (8);
}

int can_odrive_right_set_controller_mode_unpack(
    struct can_odrive_right_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u)
    {
        return (-EINVAL);
    }

    dst_p->control_mode = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->control_mode |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->control_mode |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->control_mode |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->input_mode = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->input_mode |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->input_mode |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->input_mode |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

uint32_t can_odrive_right_set_controller_mode_control_mode_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_right_set_controller_mode_control_mode_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_right_set_controller_mode_control_mode_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t can_odrive_right_set_controller_mode_input_mode_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_right_set_controller_mode_input_mode_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_right_set_controller_mode_input_mode_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_odrive_right_set_input_pos_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_set_input_pos_t *src_p,
    size_t size)
{
    uint16_t torque_ff;
    uint16_t vel_ff;
    uint32_t input_pos;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&input_pos, &src_p->input_pos, sizeof(input_pos));
    dst_p[0] |= pack_left_shift_u32(input_pos, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(input_pos, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(input_pos, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(input_pos, 24u, 0xffu);
    vel_ff = (uint16_t)src_p->vel_ff;
    dst_p[4] |= pack_left_shift_u16(vel_ff, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(vel_ff, 8u, 0xffu);
    torque_ff = (uint16_t)src_p->torque_ff;
    dst_p[6] |= pack_left_shift_u16(torque_ff, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(torque_ff, 8u, 0xffu);

    return (8);
}

int can_odrive_right_set_input_pos_unpack(
    struct can_odrive_right_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t torque_ff;
    uint16_t vel_ff;
    uint32_t input_pos;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    input_pos = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    input_pos |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    input_pos |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    input_pos |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->input_pos, &input_pos, sizeof(dst_p->input_pos));
    vel_ff = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    vel_ff |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->vel_ff = (int16_t)vel_ff;
    torque_ff = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    torque_ff |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->torque_ff = (int16_t)torque_ff;

    return (0);
}

float can_odrive_right_set_input_pos_input_pos_encode(float value)
{
    return (float)(value);
}

float can_odrive_right_set_input_pos_input_pos_decode(float value)
{
    return ((float)value);
}

bool can_odrive_right_set_input_pos_input_pos_is_in_range(float value)
{
    (void)value;

    return (true);
}

int16_t can_odrive_right_set_input_pos_vel_ff_encode(float value)
{
    return (int16_t)(value / 0.001f);
}

float can_odrive_right_set_input_pos_vel_ff_decode(int16_t value)
{
    return ((float)value * 0.001f);
}

bool can_odrive_right_set_input_pos_vel_ff_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_odrive_right_set_input_pos_torque_ff_encode(float value)
{
    return (int16_t)(value / 0.001f);
}

float can_odrive_right_set_input_pos_torque_ff_decode(int16_t value)
{
    return ((float)value * 0.001f);
}

bool can_odrive_right_set_input_pos_torque_ff_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_odrive_right_set_input_vel_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_set_input_vel_t *src_p,
    size_t size)
{
    uint32_t input_vel;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&input_vel, &src_p->input_vel, sizeof(input_vel));
    dst_p[0] |= pack_left_shift_u32(input_vel, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(input_vel, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(input_vel, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(input_vel, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->input_torque_ff, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->input_torque_ff, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->input_torque_ff, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->input_torque_ff, 24u, 0xffu);

    return (8);
}

int can_odrive_right_set_input_vel_unpack(
    struct can_odrive_right_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t input_vel;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    input_vel = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    input_vel |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    input_vel |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    input_vel |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->input_vel, &input_vel, sizeof(dst_p->input_vel));
    dst_p->input_torque_ff = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->input_torque_ff |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->input_torque_ff |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->input_torque_ff |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

float can_odrive_right_set_input_vel_input_vel_encode(float value)
{
    return (float)(value / 6.283185307179586f);
}

float can_odrive_right_set_input_vel_input_vel_decode(float value)
{
    return ((float)value * 6.283185307179586f);
}

bool can_odrive_right_set_input_vel_input_vel_is_in_range(float value)
{
    (void)value;

    return (true);
}

uint32_t can_odrive_right_set_input_vel_input_torque_ff_encode(float value)
{
    return (uint32_t)(value);
}

float can_odrive_right_set_input_vel_input_torque_ff_decode(uint32_t value)
{
    return ((float)value);
}

bool can_odrive_right_set_input_vel_input_torque_ff_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_odrive_right_set_input_torque_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_set_input_torque_t *src_p,
    size_t size)
{
    uint32_t imput_torque;

    if (size < 4u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&imput_torque, &src_p->imput_torque, sizeof(imput_torque));
    dst_p[0] |= pack_left_shift_u32(imput_torque, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(imput_torque, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(imput_torque, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(imput_torque, 24u, 0xffu);

    return (4);
}

int can_odrive_right_set_input_torque_unpack(
    struct can_odrive_right_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t imput_torque;

    if (size < 4u)
    {
        return (-EINVAL);
    }

    imput_torque = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    imput_torque |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    imput_torque |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    imput_torque |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->imput_torque, &imput_torque, sizeof(dst_p->imput_torque));

    return (0);
}

float can_odrive_right_set_input_torque_imput_torque_encode(float value)
{
    return (float)(value);
}

float can_odrive_right_set_input_torque_imput_torque_decode(float value)
{
    return ((float)value);
}

bool can_odrive_right_set_input_torque_imput_torque_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_odrive_right_set_limits_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_set_limits_t *src_p,
    size_t size)
{
    uint32_t current_limit;
    uint32_t velocity_limit;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&velocity_limit, &src_p->velocity_limit, sizeof(velocity_limit));
    dst_p[0] |= pack_left_shift_u32(velocity_limit, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(velocity_limit, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(velocity_limit, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(velocity_limit, 24u, 0xffu);
    memcpy(&current_limit, &src_p->current_limit, sizeof(current_limit));
    dst_p[4] |= pack_left_shift_u32(current_limit, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(current_limit, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(current_limit, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(current_limit, 24u, 0xffu);

    return (8);
}

int can_odrive_right_set_limits_unpack(
    struct can_odrive_right_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t current_limit;
    uint32_t velocity_limit;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    velocity_limit = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    velocity_limit |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    velocity_limit |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    velocity_limit |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->velocity_limit, &velocity_limit, sizeof(dst_p->velocity_limit));
    current_limit = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    current_limit |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    current_limit |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    current_limit |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->current_limit, &current_limit, sizeof(dst_p->current_limit));

    return (0);
}

float can_odrive_right_set_limits_velocity_limit_encode(float value)
{
    return (float)(value);
}

float can_odrive_right_set_limits_velocity_limit_decode(float value)
{
    return ((float)value);
}

bool can_odrive_right_set_limits_velocity_limit_is_in_range(float value)
{
    (void)value;

    return (true);
}

float can_odrive_right_set_limits_current_limit_encode(float value)
{
    return (float)(value);
}

float can_odrive_right_set_limits_current_limit_decode(float value)
{
    return ((float)value);
}

bool can_odrive_right_set_limits_current_limit_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_odrive_right_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_get_vbus_voltage_t *src_p,
    size_t size)
{
    uint32_t vbus_voltage;

    if (size < 4u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&vbus_voltage, &src_p->vbus_voltage, sizeof(vbus_voltage));
    dst_p[0] |= pack_left_shift_u32(vbus_voltage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(vbus_voltage, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(vbus_voltage, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(vbus_voltage, 24u, 0xffu);

    return (4);
}

int can_odrive_right_get_vbus_voltage_unpack(
    struct can_odrive_right_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t vbus_voltage;

    if (size < 4u)
    {
        return (-EINVAL);
    }

    vbus_voltage = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    vbus_voltage |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    vbus_voltage |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    vbus_voltage |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->vbus_voltage, &vbus_voltage, sizeof(dst_p->vbus_voltage));

    return (0);
}

float can_odrive_right_get_vbus_voltage_vbus_voltage_encode(float value)
{
    return (float)(value);
}

float can_odrive_right_get_vbus_voltage_vbus_voltage_decode(float value)
{
    return ((float)value);
}

bool can_odrive_right_get_vbus_voltage_vbus_voltage_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_odrive_right_clear_errors_pack(
    uint8_t *dst_p,
    const struct can_odrive_right_clear_errors_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_odrive_right_clear_errors_unpack(
    struct can_odrive_right_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_temperature_imu_status_pack(
    uint8_t *dst_p,
    const struct can_temperature_imu_status_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->accelerometer, 0u, 0xffu);

    return (1);
}

int can_temperature_imu_status_unpack(
    struct can_temperature_imu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->accelerometer = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t can_temperature_imu_status_accelerometer_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_imu_status_accelerometer_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_imu_status_accelerometer_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

int can_temperature_imu_temperature_pack(
    uint8_t *dst_p,
    const struct can_temperature_imu_temperature_t *src_p,
    size_t size)
{
    uint8_t accelerometer;

    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    accelerometer = (uint8_t)src_p->accelerometer;
    dst_p[0] |= pack_left_shift_u8(accelerometer, 0u, 0xffu);

    return (1);
}

int can_temperature_imu_temperature_unpack(
    struct can_temperature_imu_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t accelerometer;

    if (size < 1u)
    {
        return (-EINVAL);
    }

    accelerometer = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->accelerometer = (int8_t)accelerometer;

    return (0);
}

int8_t can_temperature_imu_temperature_accelerometer_encode(float value)
{
    return (int8_t)(value);
}

float can_temperature_imu_temperature_accelerometer_decode(int8_t value)
{
    return ((float)value);
}

bool can_temperature_imu_temperature_accelerometer_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int can_temperature_imu_warnings_pack(
    uint8_t *dst_p,
    const struct can_temperature_imu_warnings_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->accelerometer_over, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->accelerometer_under, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->accelerometer_critical_over, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->accelerometer_critical_under, 3u, 0x08u);

    return (1);
}

int can_temperature_imu_warnings_unpack(
    struct can_temperature_imu_warnings_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->accelerometer_over = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->accelerometer_under = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->accelerometer_critical_over = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->accelerometer_critical_under = unpack_right_shift_u8(src_p[0], 3u, 0x08u);

    return (0);
}

uint8_t can_temperature_imu_warnings_accelerometer_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_imu_warnings_accelerometer_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_imu_warnings_accelerometer_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_imu_warnings_accelerometer_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_imu_warnings_accelerometer_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_imu_warnings_accelerometer_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_imu_warnings_accelerometer_critical_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_imu_warnings_accelerometer_critical_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_imu_warnings_accelerometer_critical_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_imu_warnings_accelerometer_critical_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_imu_warnings_accelerometer_critical_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_imu_warnings_accelerometer_critical_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_temperature_external_status_pack(
    uint8_t *dst_p,
    const struct can_temperature_external_status_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->external_1, 0u, 0x03u);
    dst_p[0] |= pack_left_shift_u8(src_p->external_2, 2u, 0x0cu);
    dst_p[0] |= pack_left_shift_u8(src_p->external_3, 4u, 0x30u);
    dst_p[0] |= pack_left_shift_u8(src_p->external_4, 6u, 0xc0u);

    return (1);
}

int can_temperature_external_status_unpack(
    struct can_temperature_external_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->external_1 = unpack_right_shift_u8(src_p[0], 0u, 0x03u);
    dst_p->external_2 = unpack_right_shift_u8(src_p[0], 2u, 0x0cu);
    dst_p->external_3 = unpack_right_shift_u8(src_p[0], 4u, 0x30u);
    dst_p->external_4 = unpack_right_shift_u8(src_p[0], 6u, 0xc0u);

    return (0);
}

uint8_t can_temperature_external_status_external_1_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_status_external_1_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_status_external_1_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

uint8_t can_temperature_external_status_external_2_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_status_external_2_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_status_external_2_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

uint8_t can_temperature_external_status_external_3_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_status_external_3_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_status_external_3_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

uint8_t can_temperature_external_status_external_4_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_status_external_4_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_status_external_4_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

int can_temperature_external_temperature_pack(
    uint8_t *dst_p,
    const struct can_temperature_external_temperature_t *src_p,
    size_t size)
{
    uint8_t external_1;
    uint8_t external_2;
    uint8_t external_3;
    uint8_t external_4;

    if (size < 4u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    external_1 = (uint8_t)src_p->external_1;
    dst_p[0] |= pack_left_shift_u8(external_1, 0u, 0xffu);
    external_2 = (uint8_t)src_p->external_2;
    dst_p[1] |= pack_left_shift_u8(external_2, 0u, 0xffu);
    external_3 = (uint8_t)src_p->external_3;
    dst_p[2] |= pack_left_shift_u8(external_3, 0u, 0xffu);
    external_4 = (uint8_t)src_p->external_4;
    dst_p[3] |= pack_left_shift_u8(external_4, 0u, 0xffu);

    return (4);
}

int can_temperature_external_temperature_unpack(
    struct can_temperature_external_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t external_1;
    uint8_t external_2;
    uint8_t external_3;
    uint8_t external_4;

    if (size < 4u)
    {
        return (-EINVAL);
    }

    external_1 = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->external_1 = (int8_t)external_1;
    external_2 = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->external_2 = (int8_t)external_2;
    external_3 = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->external_3 = (int8_t)external_3;
    external_4 = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->external_4 = (int8_t)external_4;

    return (0);
}

int8_t can_temperature_external_temperature_external_1_encode(float value)
{
    return (int8_t)(value);
}

float can_temperature_external_temperature_external_1_decode(int8_t value)
{
    return ((float)value);
}

bool can_temperature_external_temperature_external_1_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t can_temperature_external_temperature_external_2_encode(float value)
{
    return (int8_t)(value);
}

float can_temperature_external_temperature_external_2_decode(int8_t value)
{
    return ((float)value);
}

bool can_temperature_external_temperature_external_2_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t can_temperature_external_temperature_external_3_encode(float value)
{
    return (int8_t)(value);
}

float can_temperature_external_temperature_external_3_decode(int8_t value)
{
    return ((float)value);
}

bool can_temperature_external_temperature_external_3_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t can_temperature_external_temperature_external_4_encode(float value)
{
    return (int8_t)(value);
}

float can_temperature_external_temperature_external_4_decode(int8_t value)
{
    return ((float)value);
}

bool can_temperature_external_temperature_external_4_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int can_temperature_external_warnings_pack(
    uint8_t *dst_p,
    const struct can_temperature_external_warnings_t *src_p,
    size_t size)
{
    if (size < 2u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u8(src_p->external_1_over, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->external_1_under, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->external_1_critical_over, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->external_1_critical_under, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->external_2_over, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->external_2_under, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->external_2_critical_over, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->external_2_critical_under, 7u, 0x80u);
    dst_p[1] |= pack_left_shift_u8(src_p->external_3_over, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->external_3_under, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->external_3_critical_over, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->external_3_critical_under, 3u, 0x08u);
    dst_p[1] |= pack_left_shift_u8(src_p->external_4_over, 4u, 0x10u);
    dst_p[1] |= pack_left_shift_u8(src_p->external_4_under, 5u, 0x20u);
    dst_p[1] |= pack_left_shift_u8(src_p->external_4_critical_over, 6u, 0x40u);
    dst_p[1] |= pack_left_shift_u8(src_p->external_4_critical_under, 7u, 0x80u);

    return (2);
}

int can_temperature_external_warnings_unpack(
    struct can_temperature_external_warnings_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u)
    {
        return (-EINVAL);
    }

    dst_p->external_1_over = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->external_1_under = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->external_1_critical_over = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->external_1_critical_under = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->external_2_over = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->external_2_under = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->external_2_critical_over = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->external_2_critical_under = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    dst_p->external_3_over = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->external_3_under = unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->external_3_critical_over = unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->external_3_critical_under = unpack_right_shift_u8(src_p[1], 3u, 0x08u);
    dst_p->external_4_over = unpack_right_shift_u8(src_p[1], 4u, 0x10u);
    dst_p->external_4_under = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    dst_p->external_4_critical_over = unpack_right_shift_u8(src_p[1], 6u, 0x40u);
    dst_p->external_4_critical_under = unpack_right_shift_u8(src_p[1], 7u, 0x80u);

    return (0);
}

uint8_t can_temperature_external_warnings_external_1_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_1_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_1_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_1_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_1_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_1_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_1_critical_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_1_critical_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_1_critical_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_1_critical_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_1_critical_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_1_critical_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_2_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_2_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_2_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_2_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_2_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_2_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_2_critical_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_2_critical_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_2_critical_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_2_critical_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_2_critical_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_2_critical_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_3_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_3_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_3_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_3_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_3_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_3_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_3_critical_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_3_critical_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_3_critical_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_3_critical_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_3_critical_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_3_critical_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_4_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_4_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_4_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_4_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_4_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_4_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_4_critical_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_4_critical_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_4_critical_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_external_warnings_external_4_critical_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_external_warnings_external_4_critical_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_external_warnings_external_4_critical_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_temperature_sensor_board_status_pack(
    uint8_t *dst_p,
    const struct can_temperature_sensor_board_status_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller, 0u, 0x03u);
    dst_p[0] |= pack_left_shift_u8(src_p->ambient, 2u, 0x0cu);
    dst_p[0] |= pack_left_shift_u8(src_p->ldo, 4u, 0x30u);

    return (1);
}

int can_temperature_sensor_board_status_unpack(
    struct can_temperature_sensor_board_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->ucontroller = unpack_right_shift_u8(src_p[0], 0u, 0x03u);
    dst_p->ambient = unpack_right_shift_u8(src_p[0], 2u, 0x0cu);
    dst_p->ldo = unpack_right_shift_u8(src_p[0], 4u, 0x30u);

    return (0);
}

uint8_t can_temperature_sensor_board_status_ucontroller_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_status_ucontroller_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_status_ucontroller_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

uint8_t can_temperature_sensor_board_status_ambient_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_status_ambient_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_status_ambient_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

uint8_t can_temperature_sensor_board_status_ldo_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_status_ldo_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_status_ldo_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

int can_temperature_sensor_board_temperature_pack(
    uint8_t *dst_p,
    const struct can_temperature_sensor_board_temperature_t *src_p,
    size_t size)
{
    uint8_t ambient;
    uint8_t ldo;
    uint8_t ucontroller;

    if (size < 3u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 3);

    ucontroller = (uint8_t)src_p->ucontroller;
    dst_p[0] |= pack_left_shift_u8(ucontroller, 0u, 0xffu);
    ambient = (uint8_t)src_p->ambient;
    dst_p[1] |= pack_left_shift_u8(ambient, 0u, 0xffu);
    ldo = (uint8_t)src_p->ldo;
    dst_p[2] |= pack_left_shift_u8(ldo, 0u, 0xffu);

    return (3);
}

int can_temperature_sensor_board_temperature_unpack(
    struct can_temperature_sensor_board_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t ambient;
    uint8_t ldo;
    uint8_t ucontroller;

    if (size < 3u)
    {
        return (-EINVAL);
    }

    ucontroller = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->ucontroller = (int8_t)ucontroller;
    ambient = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->ambient = (int8_t)ambient;
    ldo = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->ldo = (int8_t)ldo;

    return (0);
}

int8_t can_temperature_sensor_board_temperature_ucontroller_encode(float value)
{
    return (int8_t)(value);
}

float can_temperature_sensor_board_temperature_ucontroller_decode(int8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_temperature_ucontroller_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t can_temperature_sensor_board_temperature_ambient_encode(float value)
{
    return (int8_t)(value);
}

float can_temperature_sensor_board_temperature_ambient_decode(int8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_temperature_ambient_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t can_temperature_sensor_board_temperature_ldo_encode(float value)
{
    return (int8_t)(value);
}

float can_temperature_sensor_board_temperature_ldo_decode(int8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_temperature_ldo_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int can_temperature_sensor_board_warnings_pack(
    uint8_t *dst_p,
    const struct can_temperature_sensor_board_warnings_t *src_p,
    size_t size)
{
    if (size < 2u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller_over, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller_under, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller_critical_over, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller_critical_under, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->ambient_over, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->ambient_under, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->ambient_critical_over, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->ambient_critical_under, 7u, 0x80u);
    dst_p[1] |= pack_left_shift_u8(src_p->ldo_over, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->ldo_under, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->ldo_critical_over, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->ldo_critical_under, 3u, 0x08u);

    return (2);
}

int can_temperature_sensor_board_warnings_unpack(
    struct can_temperature_sensor_board_warnings_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u)
    {
        return (-EINVAL);
    }

    dst_p->ucontroller_over = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->ucontroller_under = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->ucontroller_critical_over = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->ucontroller_critical_under = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->ambient_over = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->ambient_under = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->ambient_critical_over = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->ambient_critical_under = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    dst_p->ldo_over = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->ldo_under = unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->ldo_critical_over = unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->ldo_critical_under = unpack_right_shift_u8(src_p[1], 3u, 0x08u);

    return (0);
}

uint8_t can_temperature_sensor_board_warnings_ucontroller_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_warnings_ucontroller_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_warnings_ucontroller_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_sensor_board_warnings_ucontroller_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_warnings_ucontroller_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_warnings_ucontroller_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_sensor_board_warnings_ucontroller_critical_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_warnings_ucontroller_critical_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_warnings_ucontroller_critical_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_sensor_board_warnings_ucontroller_critical_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_warnings_ucontroller_critical_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_warnings_ucontroller_critical_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_sensor_board_warnings_ambient_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_warnings_ambient_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_warnings_ambient_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_sensor_board_warnings_ambient_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_warnings_ambient_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_warnings_ambient_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_sensor_board_warnings_ambient_critical_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_warnings_ambient_critical_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_warnings_ambient_critical_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_sensor_board_warnings_ambient_critical_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_warnings_ambient_critical_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_warnings_ambient_critical_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_sensor_board_warnings_ldo_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_warnings_ldo_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_warnings_ldo_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_sensor_board_warnings_ldo_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_warnings_ldo_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_warnings_ldo_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_sensor_board_warnings_ldo_critical_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_warnings_ldo_critical_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_warnings_ldo_critical_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_sensor_board_warnings_ldo_critical_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_sensor_board_warnings_ldo_critical_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_sensor_board_warnings_ldo_critical_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_temperature_power_board_status_pack(
    uint8_t *dst_p,
    const struct can_temperature_power_board_status_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller, 0u, 0x03u);
    dst_p[0] |= pack_left_shift_u8(src_p->ambient, 2u, 0x0cu);
    dst_p[0] |= pack_left_shift_u8(src_p->mosfets, 4u, 0x30u);

    return (1);
}

int can_temperature_power_board_status_unpack(
    struct can_temperature_power_board_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->ucontroller = unpack_right_shift_u8(src_p[0], 0u, 0x03u);
    dst_p->ambient = unpack_right_shift_u8(src_p[0], 2u, 0x0cu);
    dst_p->mosfets = unpack_right_shift_u8(src_p[0], 4u, 0x30u);

    return (0);
}

uint8_t can_temperature_power_board_status_ucontroller_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_status_ucontroller_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_status_ucontroller_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

uint8_t can_temperature_power_board_status_ambient_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_status_ambient_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_status_ambient_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

uint8_t can_temperature_power_board_status_mosfets_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_status_mosfets_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_status_mosfets_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

int can_temperature_power_board_temperature_pack(
    uint8_t *dst_p,
    const struct can_temperature_power_board_temperature_t *src_p,
    size_t size)
{
    uint8_t ambient;
    uint8_t mosfets;
    uint8_t ucontroller;

    if (size < 3u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 3);

    ucontroller = (uint8_t)src_p->ucontroller;
    dst_p[0] |= pack_left_shift_u8(ucontroller, 0u, 0xffu);
    ambient = (uint8_t)src_p->ambient;
    dst_p[1] |= pack_left_shift_u8(ambient, 0u, 0xffu);
    mosfets = (uint8_t)src_p->mosfets;
    dst_p[2] |= pack_left_shift_u8(mosfets, 0u, 0xffu);

    return (3);
}

int can_temperature_power_board_temperature_unpack(
    struct can_temperature_power_board_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t ambient;
    uint8_t mosfets;
    uint8_t ucontroller;

    if (size < 3u)
    {
        return (-EINVAL);
    }

    ucontroller = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->ucontroller = (int8_t)ucontroller;
    ambient = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->ambient = (int8_t)ambient;
    mosfets = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->mosfets = (int8_t)mosfets;

    return (0);
}

int8_t can_temperature_power_board_temperature_ucontroller_encode(float value)
{
    return (int8_t)(value);
}

float can_temperature_power_board_temperature_ucontroller_decode(int8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_temperature_ucontroller_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t can_temperature_power_board_temperature_ambient_encode(float value)
{
    return (int8_t)(value);
}

float can_temperature_power_board_temperature_ambient_decode(int8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_temperature_ambient_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t can_temperature_power_board_temperature_mosfets_encode(float value)
{
    return (int8_t)(value);
}

float can_temperature_power_board_temperature_mosfets_decode(int8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_temperature_mosfets_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int can_temperature_power_board_warnings_pack(
    uint8_t *dst_p,
    const struct can_temperature_power_board_warnings_t *src_p,
    size_t size)
{
    if (size < 2u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller_over, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller_under, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller_critical_over, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller_critical_under, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->ambient_over, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->ambient_under, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->ambient_critical_over, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->ambient_critical_under, 7u, 0x80u);
    dst_p[1] |= pack_left_shift_u8(src_p->mosfets_over, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->mosfets_under, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->mosfets_critical_over, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->mosfets_critical_under, 3u, 0x08u);

    return (2);
}

int can_temperature_power_board_warnings_unpack(
    struct can_temperature_power_board_warnings_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u)
    {
        return (-EINVAL);
    }

    dst_p->ucontroller_over = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->ucontroller_under = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->ucontroller_critical_over = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->ucontroller_critical_under = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->ambient_over = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->ambient_under = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->ambient_critical_over = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->ambient_critical_under = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    dst_p->mosfets_over = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->mosfets_under = unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->mosfets_critical_over = unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->mosfets_critical_under = unpack_right_shift_u8(src_p[1], 3u, 0x08u);

    return (0);
}

uint8_t can_temperature_power_board_warnings_ucontroller_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_warnings_ucontroller_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_warnings_ucontroller_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_power_board_warnings_ucontroller_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_warnings_ucontroller_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_warnings_ucontroller_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_power_board_warnings_ucontroller_critical_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_warnings_ucontroller_critical_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_warnings_ucontroller_critical_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_power_board_warnings_ucontroller_critical_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_warnings_ucontroller_critical_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_warnings_ucontroller_critical_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_power_board_warnings_ambient_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_warnings_ambient_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_warnings_ambient_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_power_board_warnings_ambient_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_warnings_ambient_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_warnings_ambient_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_power_board_warnings_ambient_critical_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_warnings_ambient_critical_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_warnings_ambient_critical_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_power_board_warnings_ambient_critical_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_warnings_ambient_critical_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_warnings_ambient_critical_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_power_board_warnings_mosfets_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_warnings_mosfets_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_warnings_mosfets_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_power_board_warnings_mosfets_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_warnings_mosfets_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_warnings_mosfets_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_power_board_warnings_mosfets_critical_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_warnings_mosfets_critical_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_warnings_mosfets_critical_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_power_board_warnings_mosfets_critical_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_power_board_warnings_mosfets_critical_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_power_board_warnings_mosfets_critical_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_temperature_metal_detector_board_status_pack(
    uint8_t *dst_p,
    const struct can_temperature_metal_detector_board_status_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller, 0u, 0x03u);

    return (1);
}

int can_temperature_metal_detector_board_status_unpack(
    struct can_temperature_metal_detector_board_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->ucontroller = unpack_right_shift_u8(src_p[0], 0u, 0x03u);

    return (0);
}

uint8_t can_temperature_metal_detector_board_status_ucontroller_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_metal_detector_board_status_ucontroller_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_metal_detector_board_status_ucontroller_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 3u));
}

int can_temperature_metal_detector_board_temperature_pack(
    uint8_t *dst_p,
    const struct can_temperature_metal_detector_board_temperature_t *src_p,
    size_t size)
{
    uint8_t ucontroller;

    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    ucontroller = (uint8_t)src_p->ucontroller;
    dst_p[0] |= pack_left_shift_u8(ucontroller, 0u, 0xffu);

    return (1);
}

int can_temperature_metal_detector_board_temperature_unpack(
    struct can_temperature_metal_detector_board_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t ucontroller;

    if (size < 1u)
    {
        return (-EINVAL);
    }

    ucontroller = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->ucontroller = (int8_t)ucontroller;

    return (0);
}

int8_t can_temperature_metal_detector_board_temperature_ucontroller_encode(float value)
{
    return (int8_t)(value);
}

float can_temperature_metal_detector_board_temperature_ucontroller_decode(int8_t value)
{
    return ((float)value);
}

bool can_temperature_metal_detector_board_temperature_ucontroller_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int can_temperature_metal_detector_board_warnings_pack(
    uint8_t *dst_p,
    const struct can_temperature_metal_detector_board_warnings_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller_over, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller_under, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller_critical_over, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->ucontroller_critical_under, 3u, 0x08u);

    return (1);
}

int can_temperature_metal_detector_board_warnings_unpack(
    struct can_temperature_metal_detector_board_warnings_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->ucontroller_over = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->ucontroller_under = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->ucontroller_critical_over = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->ucontroller_critical_under = unpack_right_shift_u8(src_p[0], 3u, 0x08u);

    return (0);
}

uint8_t can_temperature_metal_detector_board_warnings_ucontroller_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_metal_detector_board_warnings_ucontroller_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_metal_detector_board_warnings_ucontroller_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_metal_detector_board_warnings_ucontroller_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_metal_detector_board_warnings_ucontroller_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_metal_detector_board_warnings_ucontroller_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_metal_detector_board_warnings_ucontroller_critical_over_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_metal_detector_board_warnings_ucontroller_critical_over_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_metal_detector_board_warnings_ucontroller_critical_over_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_temperature_metal_detector_board_warnings_ucontroller_critical_under_encode(float value)
{
    return (uint8_t)(value);
}

float can_temperature_metal_detector_board_warnings_ucontroller_critical_under_decode(uint8_t value)
{
    return ((float)value);
}

bool can_temperature_metal_detector_board_warnings_ucontroller_critical_under_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_konarm_1_status_pack(
    uint8_t *dst_p,
    const struct can_konarm_1_status_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->status, 0u, 0xffu);

    return (1);
}

int can_konarm_1_status_unpack(
    struct can_konarm_1_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->status = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t can_konarm_1_status_status_encode(float value)
{
    return (uint8_t)(value);
}

float can_konarm_1_status_status_decode(uint8_t value)
{
    return ((float)value);
}

bool can_konarm_1_status_status_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 4u));
}

int can_konarm_1_set_pos_pack(
    uint8_t *dst_p,
    const struct can_konarm_1_set_pos_t *src_p,
    size_t size)
{
    uint32_t position;
    uint32_t velocity;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&position, &src_p->position, sizeof(position));
    dst_p[0] |= pack_left_shift_u32(position, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(position, 24u, 0xffu);
    memcpy(&velocity, &src_p->velocity, sizeof(velocity));
    dst_p[4] |= pack_left_shift_u32(velocity, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(velocity, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(velocity, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(velocity, 24u, 0xffu);

    return (8);
}

int can_konarm_1_set_pos_unpack(
    struct can_konarm_1_set_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t position;
    uint32_t velocity;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    position = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    position |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    position |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    position |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->position, &position, sizeof(dst_p->position));
    velocity = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->velocity, &velocity, sizeof(dst_p->velocity));

    return (0);
}

float can_konarm_1_set_pos_position_encode(float value)
{
    return (float)(value);
}

float can_konarm_1_set_pos_position_decode(float value)
{
    return ((float)value);
}

bool can_konarm_1_set_pos_position_is_in_range(float value)
{
    (void)value;

    return (true);
}

float can_konarm_1_set_pos_velocity_encode(float value)
{
    return (float)(value);
}

float can_konarm_1_set_pos_velocity_decode(float value)
{
    return ((float)value);
}

bool can_konarm_1_set_pos_velocity_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_konarm_1_get_pos_pack(
    uint8_t *dst_p,
    const struct can_konarm_1_get_pos_t *src_p,
    size_t size)
{
    uint32_t position;
    uint32_t velocity;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&position, &src_p->position, sizeof(position));
    dst_p[0] |= pack_left_shift_u32(position, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(position, 24u, 0xffu);
    memcpy(&velocity, &src_p->velocity, sizeof(velocity));
    dst_p[4] |= pack_left_shift_u32(velocity, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(velocity, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(velocity, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(velocity, 24u, 0xffu);

    return (8);
}

int can_konarm_1_get_pos_unpack(
    struct can_konarm_1_get_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t position;
    uint32_t velocity;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    position = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    position |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    position |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    position |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->position, &position, sizeof(dst_p->position));
    velocity = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->velocity, &velocity, sizeof(dst_p->velocity));

    return (0);
}

float can_konarm_1_get_pos_position_encode(float value)
{
    return (float)(value);
}

float can_konarm_1_get_pos_position_decode(float value)
{
    return ((float)value);
}

bool can_konarm_1_get_pos_position_is_in_range(float value)
{
    (void)value;

    return (true);
}

float can_konarm_1_get_pos_velocity_encode(float value)
{
    return (float)(value);
}

float can_konarm_1_get_pos_velocity_decode(float value)
{
    return ((float)value);
}

bool can_konarm_1_get_pos_velocity_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_konarm_1_clear_errors_pack(
    uint8_t *dst_p,
    const struct can_konarm_1_clear_errors_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_konarm_1_clear_errors_unpack(
    struct can_konarm_1_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_konarm_2_status_pack(
    uint8_t *dst_p,
    const struct can_konarm_2_status_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->status, 0u, 0xffu);

    return (1);
}

int can_konarm_2_status_unpack(
    struct can_konarm_2_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->status = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t can_konarm_2_status_status_encode(float value)
{
    return (uint8_t)(value);
}

float can_konarm_2_status_status_decode(uint8_t value)
{
    return ((float)value);
}

bool can_konarm_2_status_status_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 4u));
}

int can_konarm_2_set_pos_pack(
    uint8_t *dst_p,
    const struct can_konarm_2_set_pos_t *src_p,
    size_t size)
{
    uint32_t position;
    uint32_t velocity;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&position, &src_p->position, sizeof(position));
    dst_p[0] |= pack_left_shift_u32(position, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(position, 24u, 0xffu);
    memcpy(&velocity, &src_p->velocity, sizeof(velocity));
    dst_p[4] |= pack_left_shift_u32(velocity, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(velocity, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(velocity, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(velocity, 24u, 0xffu);

    return (8);
}

int can_konarm_2_set_pos_unpack(
    struct can_konarm_2_set_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t position;
    uint32_t velocity;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    position = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    position |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    position |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    position |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->position, &position, sizeof(dst_p->position));
    velocity = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->velocity, &velocity, sizeof(dst_p->velocity));

    return (0);
}

float can_konarm_2_set_pos_position_encode(float value)
{
    return (float)(value);
}

float can_konarm_2_set_pos_position_decode(float value)
{
    return ((float)value);
}

bool can_konarm_2_set_pos_position_is_in_range(float value)
{
    (void)value;

    return (true);
}

float can_konarm_2_set_pos_velocity_encode(float value)
{
    return (float)(value);
}

float can_konarm_2_set_pos_velocity_decode(float value)
{
    return ((float)value);
}

bool can_konarm_2_set_pos_velocity_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_konarm_2_get_pos_pack(
    uint8_t *dst_p,
    const struct can_konarm_2_get_pos_t *src_p,
    size_t size)
{
    uint32_t position;
    uint32_t velocity;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&position, &src_p->position, sizeof(position));
    dst_p[0] |= pack_left_shift_u32(position, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(position, 24u, 0xffu);
    memcpy(&velocity, &src_p->velocity, sizeof(velocity));
    dst_p[4] |= pack_left_shift_u32(velocity, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(velocity, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(velocity, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(velocity, 24u, 0xffu);

    return (8);
}

int can_konarm_2_get_pos_unpack(
    struct can_konarm_2_get_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t position;
    uint32_t velocity;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    position = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    position |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    position |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    position |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->position, &position, sizeof(dst_p->position));
    velocity = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->velocity, &velocity, sizeof(dst_p->velocity));

    return (0);
}

float can_konarm_2_get_pos_position_encode(float value)
{
    return (float)(value);
}

float can_konarm_2_get_pos_position_decode(float value)
{
    return ((float)value);
}

bool can_konarm_2_get_pos_position_is_in_range(float value)
{
    (void)value;

    return (true);
}

float can_konarm_2_get_pos_velocity_encode(float value)
{
    return (float)(value);
}

float can_konarm_2_get_pos_velocity_decode(float value)
{
    return ((float)value);
}

bool can_konarm_2_get_pos_velocity_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_konarm_2_clear_errors_pack(
    uint8_t *dst_p,
    const struct can_konarm_2_clear_errors_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_konarm_2_clear_errors_unpack(
    struct can_konarm_2_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_konarm_3_status_pack(
    uint8_t *dst_p,
    const struct can_konarm_3_status_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->status, 0u, 0xffu);

    return (1);
}

int can_konarm_3_status_unpack(
    struct can_konarm_3_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u)
    {
        return (-EINVAL);
    }

    dst_p->status = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t can_konarm_3_status_status_encode(float value)
{
    return (uint8_t)(value);
}

float can_konarm_3_status_status_decode(uint8_t value)
{
    return ((float)value);
}

bool can_konarm_3_status_status_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 4u));
}

int can_konarm_3_set_pos_pack(
    uint8_t *dst_p,
    const struct can_konarm_3_set_pos_t *src_p,
    size_t size)
{
    uint32_t position;
    uint32_t velocity;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&position, &src_p->position, sizeof(position));
    dst_p[0] |= pack_left_shift_u32(position, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(position, 24u, 0xffu);
    memcpy(&velocity, &src_p->velocity, sizeof(velocity));
    dst_p[4] |= pack_left_shift_u32(velocity, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(velocity, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(velocity, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(velocity, 24u, 0xffu);

    return (8);
}

int can_konarm_3_set_pos_unpack(
    struct can_konarm_3_set_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t position;
    uint32_t velocity;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    position = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    position |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    position |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    position |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->position, &position, sizeof(dst_p->position));
    velocity = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->velocity, &velocity, sizeof(dst_p->velocity));

    return (0);
}

float can_konarm_3_set_pos_position_encode(float value)
{
    return (float)(value);
}

float can_konarm_3_set_pos_position_decode(float value)
{
    return ((float)value);
}

bool can_konarm_3_set_pos_position_is_in_range(float value)
{
    (void)value;

    return (true);
}

float can_konarm_3_set_pos_velocity_encode(float value)
{
    return (float)(value);
}

float can_konarm_3_set_pos_velocity_decode(float value)
{
    return ((float)value);
}

bool can_konarm_3_set_pos_velocity_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_konarm_3_get_pos_pack(
    uint8_t *dst_p,
    const struct can_konarm_3_get_pos_t *src_p,
    size_t size)
{
    uint32_t position;
    uint32_t velocity;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&position, &src_p->position, sizeof(position));
    dst_p[0] |= pack_left_shift_u32(position, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(position, 24u, 0xffu);
    memcpy(&velocity, &src_p->velocity, sizeof(velocity));
    dst_p[4] |= pack_left_shift_u32(velocity, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(velocity, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(velocity, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(velocity, 24u, 0xffu);

    return (8);
}

int can_konarm_3_get_pos_unpack(
    struct can_konarm_3_get_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t position;
    uint32_t velocity;

    if (size < 8u)
    {
        return (-EINVAL);
    }

    position = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    position |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    position |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    position |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->position, &position, sizeof(dst_p->position));
    velocity = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    velocity |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->velocity, &velocity, sizeof(dst_p->velocity));

    return (0);
}

float can_konarm_3_get_pos_position_encode(float value)
{
    return (float)(value);
}

float can_konarm_3_get_pos_position_decode(float value)
{
    return ((float)value);
}

bool can_konarm_3_get_pos_position_is_in_range(float value)
{
    (void)value;

    return (true);
}

float can_konarm_3_get_pos_velocity_encode(float value)
{
    return (float)(value);
}

float can_konarm_3_get_pos_velocity_decode(float value)
{
    return ((float)value);
}

bool can_konarm_3_get_pos_velocity_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_konarm_3_clear_errors_pack(
    uint8_t *dst_p,
    const struct can_konarm_3_clear_errors_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int can_konarm_3_clear_errors_unpack(
    struct can_konarm_3_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}
